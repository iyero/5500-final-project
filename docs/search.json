[
  {
    "objectID": "script/04_visualization.html",
    "href": "script/04_visualization.html",
    "title": "High Tide Ahead",
    "section": "",
    "text": "# Import libraries\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport rasterio\nfrom rasterio.plot import show\nimport folium\nfrom folium import plugins\nimport json\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mcolors\nfrom branca.colormap import LinearColormap\nimport warnings\nwarnings.filterwarnings('ignore')\n\nprint(\"‚úì Libraries imported\")\n\n# Load processed data - USE NEW FILE\ncensus_bg = gpd.read_file('data/processed/census_bg_exposure.shp')\nhonolulu = gpd.read_file('data/processed/honolulu_boundary.shp')\nwaterways = gpd.read_file('data/processed/waterways_honolulu.shp')\nlines = gpd.read_file('data/processed/lines_honolulu.shp')\n\n# Fix truncated shapefile column names\ncensus_bg = census_bg.rename(columns={\n    'total_popu': 'total_population',\n    'pixels_mod': 'pixels_moderate',\n    'pixels_hig': 'pixels_high',\n    'pixels_tot': 'pixels_total',\n    'pct_modera': 'pct_moderate',\n    'pop_low_ri': 'pop_low_risk',\n    'pop_modera': 'pop_moderate_risk',\n    'pop_high_r': 'pop_high_risk',\n    'dominant_r': 'dominant_risk',\n    'weighted_r': 'weighted_risk_score'\n})\n\nprint(f\"‚úì Loaded data:\")\nprint(f\"  Census block groups: {len(census_bg)}\")\nprint(f\"  Waterways: {len(waterways)}\")\nprint(f\"  Coastlines: {len(lines)}\")\nprint(f\"‚úì Column names restored\")\n\n# Load risk raster\nrisk_raster_path = 'data/processed/final_flood_risk.tif'\n\n‚úì Libraries imported\n‚úì Loaded data:\n  Census block groups: 773\n  Waterways: 2340\n  Coastlines: 4\n‚úì Column names restored\n\n\n\n# Convert to WGS84 (required for Folium)\ncensus_bg_wgs84 = census_bg.to_crs('EPSG:4326')\nhonolulu_wgs84 = honolulu.to_crs('EPSG:4326')\nwaterways_wgs84 = waterways.to_crs('EPSG:4326')\nlines_wgs84 = lines.to_crs('EPSG:4326')\n\nprint(\"‚úì Data reprojected to WGS84\")\n\n# Calculate center point for map\ncenter_lat = census_bg_wgs84.geometry.centroid.y.mean()\ncenter_lon = census_bg_wgs84.geometry.centroid.x.mean()\n\nprint(f\"‚úì Map center: ({center_lat:.4f}, {center_lon:.4f})\")\n\n‚úì Data reprojected to WGS84\n‚úì Map center: (21.3680, -157.9076)\n\n\n\n# Create base map\nm = folium.Map(\n    location=[center_lat, center_lon],\n    zoom_start=10,\n    tiles='CartoDB positron',\n    control_scale=True\n)\n\n# Add title\ntitle_html = '''\n&lt;div style=\"position: fixed; \n            top: 10px; left: 50px; width: 500px; height: 90px; \n            background-color: white; border:2px solid grey; z-index:9999; \n            font-size:16px; padding: 10px\"&gt;\n&lt;h3 style=\"margin-bottom:5px;\"&gt;High Tide Ahead&lt;/h3&gt;\n&lt;p style=\"margin-top:0px;\"&gt;&lt;b&gt;Flood Risk and Population Exposure in Honolulu County&lt;/b&gt;&lt;/p&gt;\n&lt;/div&gt;\n'''\nm.get_root().html.add_child(folium.Element(title_html))\n\nprint(\"‚úì Base map created\")\n\n‚úì Base map created\n\n\n\n# Create color scale for weighted risk score\ncolormap = LinearColormap(\n    colors=['green', 'yellow', 'orange', 'red'],\n    vmin=1,\n    vmax=3,\n    caption='Weighted Flood Risk Score (1=Low, 3=High)'\n)\n\n# Add risk score layer\nfolium.GeoJson(\n    census_bg_wgs84,\n    name='Flood Risk Score',\n    style_function=lambda feature: {\n        'fillColor': colormap(feature['properties']['weighted_risk_score']),\n        'color': 'black',\n        'weight': 1,\n        'fillOpacity': 0.6\n    },\n    tooltip=folium.GeoJsonTooltip(\n        fields=['GEOID', 'total_population', 'weighted_risk_score', 'dominant_risk'],\n        aliases=['Block Group ID:', 'Population:', 'Risk Score:', 'Dominant Risk:'],\n        localize=True,\n        sticky=False,\n        labels=True,\n        style=\"\"\"\n            background-color: #F0EFEF;\n            border: 2px solid black;\n            border-radius: 3px;\n            box-shadow: 3px;\n        \"\"\",\n        max_width=800,\n    ),\n    popup=folium.GeoJsonPopup(\n        fields=['GEOID', 'total_population', 'pct_low', 'pct_moderate', 'pct_high',\n                'pop_high_risk', 'weighted_risk_score', 'dominant_risk'],  # FIXED\n        aliases=['Block Group:', 'Total Population:', '% Low Risk:', '% Moderate Risk:', '% High Risk:',\n                'Pop. in High Risk:', 'Weighted Score:', 'Dominant Category:'],\n        localize=True,\n        labels=True,\n        style=\"background-color: yellow;\",\n    ),\n    show=True\n).add_to(m)\n\n# Add colormap to map\ncolormap.add_to(m)\n\nprint(\"‚úì Flood risk choropleth added\")\n\n‚úì Flood risk choropleth added\n\n\n\n# Convert to WGS84 (required for Folium) - AFTER renaming columns\ncensus_bg_wgs84 = census_bg.to_crs('EPSG:4326')\nhonolulu_wgs84 = honolulu.to_crs('EPSG:4326')\nwaterways_wgs84 = waterways.to_crs('EPSG:4326')\nlines_wgs84 = lines.to_crs('EPSG:4326')\n\nprint(\"‚úì Data reprojected to WGS84\")\n\n‚úì Data reprojected to WGS84\n\n\n\n# Create separate layer for high-risk population exposure\ncolormap_pop = LinearColormap(\n    colors=['white', 'pink', 'red', 'darkred'],\n    vmin=0,\n    vmax=census_bg_wgs84['pop_high_risk'].quantile(0.95),\n    caption='Population Exposed to High Flood Risk'\n)\n\nfolium.GeoJson(\n    census_bg_wgs84,\n    name='Population Exposure (High Risk)',\n    style_function=lambda feature: {\n        'fillColor': colormap_pop(feature['properties']['pop_high_risk']),\n        'color': 'gray',\n        'weight': 0.5,\n        'fillOpacity': 0.7\n    },\n    tooltip=folium.GeoJsonTooltip(\n        fields=['GEOID', 'total_population', 'pop_high_risk', 'pct_high'],\n        aliases=['Block Group:', 'Total Population:', 'High Risk Exposure:', '% Area High Risk:'],\n        localize=True\n    ),\n    show=False\n).add_to(m)\n\ncolormap_pop.add_to(m)\nprint(\"‚úì Population exposure layer added\")\n\n‚úì Population exposure layer added\n\n\n\n# Add waterways\nfolium.GeoJson(\n    waterways_wgs84,\n    name='Waterways',\n    style_function=lambda x: {\n        'color': 'blue',\n        'weight': 2,\n        'opacity': 0.7\n    },\n    show=True\n).add_to(m)\n\n# Add coastlines\nfolium.GeoJson(\n    lines_wgs84,\n    name='Coastline',\n    style_function=lambda x: {\n        'color': 'darkblue',\n        'weight': 3,\n        'opacity': 0.8\n    },\n    show=True\n).add_to(m)\n\nprint(\"‚úì Water features added\")\n\n‚úì Water features added\n\n\n\n# Add Honolulu County boundary\nfolium.GeoJson(\n    honolulu_wgs84,\n    name='County Boundary',\n    style_function=lambda x: {\n        'color': 'black',\n        'weight': 3,\n        'fill': False,\n        'opacity': 1\n    },\n    show=True\n).add_to(m)\n\nprint(\"‚úì County boundary added\")\n\n‚úì County boundary added\n\n\n\n# Identify top 10 highest risk block groups\ntop_10_risk = census_bg_wgs84.nlargest(10, 'weighted_risk_score')\n\n# Create marker cluster for high-risk areas\nmarker_cluster = plugins.MarkerCluster(name='High Risk Areas (Top 10)')\n\nfor idx, row in top_10_risk.iterrows():\n    # Get centroid\n    centroid = row.geometry.centroid\n    \n    # Create popup HTML\n    popup_html = f\"\"\"\n    &lt;div style=\"width: 250px;\"&gt;\n        &lt;h4 style=\"color: darkred; margin-bottom: 5px;\"&gt;‚ö†Ô∏è High Risk Area&lt;/h4&gt;\n        &lt;b&gt;Block Group:&lt;/b&gt; {row['GEOID']}&lt;br&gt;\n        &lt;b&gt;Population:&lt;/b&gt; {row['total_population']:,.0f}&lt;br&gt;\n        &lt;b&gt;Risk Score:&lt;/b&gt; {row['weighted_risk_score']:.2f}/3.0&lt;br&gt;\n        &lt;b&gt;High Risk Area:&lt;/b&gt; {row['pct_high']:.1f}%&lt;br&gt;\n        &lt;b&gt;Population at High Risk:&lt;/b&gt; {row['pop_high_risk']:,.0f}&lt;br&gt;\n    &lt;/div&gt;\n    \"\"\"\n    \n    folium.Marker(\n        location=[centroid.y, centroid.x],\n        popup=folium.Popup(popup_html, max_width=300),\n        icon=folium.Icon(color='red', icon='exclamation-triangle', prefix='fa'),\n        tooltip=f\"High Risk: {row['GEOID']}\"\n    ).add_to(marker_cluster)\n\nmarker_cluster.add_to(m)\nprint(\"‚úì High-risk area markers added\")\n\n‚úì High-risk area markers added\n\n\n\n# Add layer control\nfolium.LayerControl(collapsed=False).add_to(m)\n\n# Add fullscreen button\nplugins.Fullscreen(\n    position='topright',\n    title='Fullscreen',\n    title_cancel='Exit Fullscreen',\n    force_separate_button=True\n).add_to(m)\n\n# Add measure control\nplugins.MeasureControl(\n    position='topleft',\n    primary_length_unit='meters',\n    secondary_length_unit='miles',\n    primary_area_unit='sqmeters',\n    secondary_area_unit='acres'\n).add_to(m)\n\n# Add minimap\nminimap = plugins.MiniMap(toggle_display=True)\nm.add_child(minimap)\n\n# Add mouse position\nplugins.MousePosition().add_to(m)\n\nprint(\"‚úì Interactive controls added\")\n\n‚úì Interactive controls added\n\n\n\n# Save map\nmap_output_path = 'outputs/maps/flood_risk_interactive_map.html'\nm.save(map_output_path)\n\nprint(f\"‚úì Interactive map saved to: {map_output_path}\")\nprint(f\"\\nüåê Open this file in a web browser to view the interactive map!\")\n\n‚úì Interactive map saved to: outputs/maps/flood_risk_interactive_map.html\n\nüåê Open this file in a web browser to view the interactive map!\n\n\n\n# !pip install matplotlib-scalebar\n\n\n\n# Filter census_bg to Oahu only (exclude NW Hawaiian Islands)\ncensus_bg['centroid_x'] = census_bg.geometry.centroid.x\ncensus_bg['centroid_y'] = census_bg.geometry.centroid.y\n\nx_median = census_bg['centroid_x'].median()\nx_std = census_bg['centroid_x'].std()\ny_median = census_bg['centroid_y'].median()\ny_std = census_bg['centroid_y'].std()\n\ncensus_bg_oahu = census_bg[\n    (census_bg['centroid_x'] &gt; (x_median - 2*x_std)) &\n    (census_bg['centroid_x'] &lt; (x_median + 2*x_std)) &\n    (census_bg['centroid_y'] &gt; (y_median - 2*y_std)) &\n    (census_bg['centroid_y'] &lt; (y_median + 2*y_std))\n].copy()\n\ncensus_bg_oahu = census_bg_oahu.drop(columns=['centroid_x', 'centroid_y'])\n\n# Get Oahu bounds for clipping other layers\noahu_bounds = census_bg_oahu.total_bounds  # [minx, miny, maxx, maxy]\n\nprint(f\"‚úì Filtered to Oahu: {len(census_bg_oahu)} block groups\")\n\n\nfig, ax = plt.subplots(1, 1, figsize=(16, 14))\n\n# Plot risk classification - USE OAHU ONLY\ncensus_bg_oahu.plot(\n    column='weighted_risk_score',\n    ax=ax,\n    legend=True,\n    cmap='RdYlGn_r',\n    edgecolor='black',\n    linewidth=0.5,\n    legend_kwds={\n        'label': 'Weighted Flood Risk Score',\n        'orientation': 'horizontal',\n        'shrink': 0.6,\n        'pad': 0.05\n    }\n)\n\n# Overlay water features\nwaterways.plot(ax=ax, color='blue', linewidth=1, alpha=0.6, label='Waterways')\nlines.plot(ax=ax, color='darkblue', linewidth=2, alpha=0.8, label='Coastline')\n\n# Add county boundary\nhonolulu.boundary.plot(ax=ax, color='black', linewidth=3, label='County Boundary')\n\n# Mark top 5 highest risk areas - USE OAHU ONLY\ntop_5 = census_bg_oahu.nlargest(5, 'weighted_risk_score')\ntop_5_centroids = top_5.geometry.centroid\n\nax.scatter(\n    top_5_centroids.x, \n    top_5_centroids.y, \n    color='red', \n    s=200, \n    marker='*', \n    edgecolor='black', \n    linewidth=2,\n    label='Top 5 Highest Risk Areas',\n    zorder=5\n)\n\n# Add labels for top risk areas\nfor idx, (x, y, score) in enumerate(zip(top_5_centroids.x, top_5_centroids.y, top_5['weighted_risk_score'])):\n    ax.annotate(\n        f'#{idx+1}\\n{score:.2f}',\n        xy=(x, y),\n        xytext=(10, 10),\n        textcoords='offset points',\n        fontsize=9,\n        fontweight='bold',\n        bbox=dict(boxstyle='round,pad=0.5', facecolor='yellow', alpha=0.8),\n        arrowprops=dict(arrowstyle='-&gt;', connectionstyle='arc3,rad=0', color='black', lw=1.5)\n    )\n\n# SET AXIS LIMITS TO OAHU BOUNDS (with small buffer)\nbuffer = 5000  # 5km buffer\nax.set_xlim(oahu_bounds[0] - buffer, oahu_bounds[2] + buffer)\nax.set_ylim(oahu_bounds[1] - buffer, oahu_bounds[3] + buffer)\n\n# Add legend\nax.legend(loc='upper left', fontsize=11, frameon=True, fancybox=True, shadow=True)\n\n# Add title and labels\nax.set_title('Flood Risk Assessment: Oahu, Honolulu County, Hawaii', \n             fontsize=18, fontweight='bold', pad=20)\nax.set_xlabel('Easting (m)', fontsize=12)\nax.set_ylabel('Northing (m)', fontsize=12)\n\n# Add north arrow\nx, y, arrow_length = 0.98, 0.98, 0.08\nax.annotate('N', xy=(x, y), xytext=(x, y-arrow_length),\n            arrowprops=dict(facecolor='black', width=5, headwidth=15),\n            ha='center', va='center', fontsize=16, fontweight='bold',\n            xycoords=ax.transAxes)\n\n# Grid\nax.grid(True, alpha=0.3, linestyle='--')\n\nplt.tight_layout()\nplt.savefig('outputs/figures/10_comprehensive_risk_map.png', dpi=300, bbox_inches='tight')\nplt.show()\n\nprint(\"‚úì Comprehensive static map saved (Oahu only)\")\n\n‚úì Filtered to Oahu: 703 block groups\n\n\n\n\n\n\n\n\n\n‚úì Comprehensive static map saved (Oahu only)\n\n\n\n# Fix truncated shapefile column names\ncensus_bg = census_bg.rename(columns={\n    'total_popu': 'total_population',\n    'pixels_mod': 'pixels_moderate',\n    'pixels_hig': 'pixels_high',\n    'pixels_tot': 'pixels_total',\n    'pct_modera': 'pct_moderate',\n    'pop_low_ri': 'pop_low_risk',\n    'pop_modera': 'pop_moderate_risk',\n    'pop_high_r': 'pop_high_risk',\n    'dominant_r': 'dominant_risk',\n    'weighted_r': 'weighted_risk_score'\n})\nprint(\"‚úì Column names restored\")\n\n‚úì Column names restored\n\n\n\n# Create Dashboard-Style Summary Figure - OAHU ONLY\nfig = plt.figure(figsize=(20, 12))\ngs = fig.add_gridspec(3, 3, hspace=0.3, wspace=0.3)\n\n# Filter to Oahu only first\ncensus_bg['centroid_x'] = census_bg.geometry.centroid.x\ncensus_bg['centroid_y'] = census_bg.geometry.centroid.y\n\nx_median = census_bg['centroid_x'].median()\nx_std = census_bg['centroid_x'].std()\ny_median = census_bg['centroid_y'].median()\ny_std = census_bg['centroid_y'].std()\n\ncensus_bg_oahu = census_bg[\n    (census_bg['centroid_x'] &gt; (x_median - 2*x_std)) &\n    (census_bg['centroid_x'] &lt; (x_median + 2*x_std)) &\n    (census_bg['centroid_y'] &gt; (y_median - 2*y_std)) &\n    (census_bg['centroid_y'] &lt; (y_median + 2*y_std))\n].copy()\n\ncensus_bg_oahu = census_bg_oahu.drop(columns=['centroid_x', 'centroid_y'], errors='ignore')\n\n# Get Oahu bounds for clipping\nbounds = census_bg_oahu.total_bounds  # [minx, miny, maxx, maxy]\nx_range = bounds[2] - bounds[0]\ny_range = bounds[3] - bounds[1]\n\n# Add buffer around Oahu\nbuffer_pct = 0.05\nx_buffer = x_range * buffer_pct\ny_buffer = y_range * buffer_pct\n\n# Panel 1: Main risk map - OAHU ONLY\nax1 = fig.add_subplot(gs[0:2, 0:2])\n\ncensus_bg_oahu.plot(\n    column='weighted_risk_score',\n    ax=ax1,\n    cmap='RdYlGn_r',\n    edgecolor='black',\n    linewidth=0.3,\n    legend=False,\n    vmin=1,\n    vmax=3\n)\nwaterways.plot(ax=ax1, color='blue', linewidth=0.5, alpha=0.5)\nhonolulu.boundary.plot(ax=ax1, color='black', linewidth=2)\n\n# Clip to Oahu only\nax1.set_xlim([bounds[0] - x_buffer, bounds[2] + x_buffer])\nax1.set_ylim([bounds[1] - y_buffer, bounds[3] + y_buffer])\nax1.set_facecolor('lightblue')  # Water background\n\nax1.set_title('Flood Risk Map (Oahu)', fontsize=14, fontweight='bold')\nax1.axis('off')\n\n# Panel 2: Population exposure bar chart - UPDATED COLUMN NAMES\nax2 = fig.add_subplot(gs[0, 2])\nrisk_cats = ['Low', 'Moderate', 'High']\npop_exp = [\n    census_bg_oahu['pop_low_risk'].sum(),\n    census_bg_oahu['pop_moderate_risk'].sum(),\n    census_bg_oahu['pop_high_risk'].sum()\n]\ncolors_bar = ['lightgreen', 'orange', 'darkred']\nbars = ax2.bar(risk_cats, pop_exp, color=colors_bar, edgecolor='black', linewidth=1.5)\nax2.set_ylabel('Population', fontsize=11, fontweight='bold')\nax2.set_title('Population Exposure', fontsize=12, fontweight='bold')\nax2.grid(axis='y', alpha=0.3)\nfor bar, val in zip(bars, pop_exp):\n    height = bar.get_height()\n    ax2.text(bar.get_x() + bar.get_width()/2., height,\n             f'{val:,.0f}', ha='center', va='bottom', fontsize=9, fontweight='bold')\n\n# Panel 3: Risk score distribution\nax3 = fig.add_subplot(gs[1, 2])\nax3.hist(census_bg_oahu['weighted_risk_score'], bins=20, color='steelblue', \n         edgecolor='black', alpha=0.7)\nax3.axvline(census_bg_oahu['weighted_risk_score'].mean(), color='red', \n           linestyle='--', linewidth=2, label=f\"Mean: {census_bg_oahu['weighted_risk_score'].mean():.2f}\")\nax3.set_xlabel('Risk Score', fontsize=11, fontweight='bold')\nax3.set_ylabel('Frequency', fontsize=11, fontweight='bold')\nax3.set_title('Risk Score Distribution', fontsize=12, fontweight='bold')\nax3.legend(fontsize=9)\nax3.grid(alpha=0.3)\n\n# Panel 4: Area by risk category (pie chart)\nax4 = fig.add_subplot(gs[2, 0])\n\n# Calculate areas\nwith rasterio.open(risk_raster_path) as src:\n    risk_data = src.read(1)\n    pixel_area_km2 = (src.res[0] ** 2) / 1e6\n\nareas = []\nfor risk_val in [1, 2, 3]:\n    pixels = np.sum(risk_data == risk_val)\n    area_km2 = pixels * pixel_area_km2\n    areas.append(area_km2)\n\nwedges, texts, autotexts = ax4.pie(\n    areas, \n    labels=risk_cats, \n    autopct='%1.1f%%',\n    colors=colors_bar,\n    startangle=90,\n    wedgeprops={'edgecolor': 'black', 'linewidth': 1.5}\n)\nfor autotext in autotexts:\n    autotext.set_color('white')\n    autotext.set_fontweight('bold')\nax4.set_title('Land Area by Risk', fontsize=12, fontweight='bold')\n\n# Panel 5: Top 5 highest risk block groups\nax5 = fig.add_subplot(gs[2, 1])\nax5.axis('off')\ntop_5_bg = census_bg_oahu.nlargest(5, 'weighted_risk_score')\ntable_data = []\nfor i, (idx, row) in enumerate(top_5_bg.iterrows(), 1):\n    table_data.append([\n        f\"#{i}\",\n        row['GEOID'][-6:],  # Last 6 digits\n        f\"{row['total_population']:.0f}\",\n        f\"{row['weighted_risk_score']:.2f}\"\n    ])\n\ntable = ax5.table(\n    cellText=table_data,\n    colLabels=['Rank', 'BG ID', 'Pop.', 'Score'],\n    cellLoc='center',\n    loc='center',\n    bbox=[0, 0, 1, 1]\n)\ntable.auto_set_font_size(False)\ntable.set_fontsize(9)\ntable.scale(1, 2)\nfor i in range(4):\n    table[(0, i)].set_facecolor('#4CAF50')\n    table[(0, i)].set_text_props(weight='bold', color='white')\nax5.set_title('Top 5 High-Risk Areas', fontsize=12, fontweight='bold', pad=20)\n\n# Panel 6: Key statistics - UPDATED COLUMN NAMES\nax6 = fig.add_subplot(gs[2, 2])\nax6.axis('off')\n\ntotal_pop = census_bg_oahu['total_population'].sum()\nhigh_risk_pop = census_bg_oahu['pop_high_risk'].sum()\nhigh_risk_pct = high_risk_pop / total_pop * 100 if total_pop &gt; 0 else 0\n\nstats_text = f\"\"\"\nKEY STATISTICS\n\nTotal Population:\n{total_pop:,.0f}\n\nHigh Risk Exposure:\n{high_risk_pop:,.0f}\n({high_risk_pct:.1f}%)\n\nBlock Groups Analyzed:\n{len(census_bg_oahu)}\n\nMean Risk Score:\n{census_bg_oahu['weighted_risk_score'].mean():.2f} / 3.0\n\nHigh Risk Area:\n{areas[2]:.1f} km¬≤\n\"\"\"\n\nax6.text(0.1, 0.5, stats_text, fontsize=11, family='monospace',\n         verticalalignment='center', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n\n# Overall title\nfig.suptitle('High Tide Ahead: Flood Risk Dashboard - Oahu, Honolulu County', \n             fontsize=20, fontweight='bold', y=0.98)\n\nplt.savefig('outputs/figures/11_dashboard_summary.png', dpi=300, bbox_inches='tight')\nplt.show()\n\nprint(\"‚úì Dashboard summary figure saved (Oahu only)\")\n\n\n\n\n\n\n\n\n‚úì Dashboard summary figure saved (Oahu only)\n\n\n\n# Create simplified GeoJSON for web mapping (smaller file size)\ncensus_simplified = census_bg_wgs84[[\n    'GEOID', 'total_population', 'weighted_risk_score', \n    'dominant_risk', 'pct_high', 'pop_high_risk', 'geometry'\n]].copy()\n\n# Round coordinates to reduce file size\ncensus_simplified['geometry'] = census_simplified['geometry'].simplify(0.0001)\n\n# Save simplified version\ncensus_simplified.to_file('outputs/maps/census_risk_simplified.geojson', driver='GeoJSON')\nprint(\"‚úì Simplified GeoJSON exported for web use\")\n\n# Export summary statistics as JSON\nsummary_stats = {\n    \"total_population\": int(census_bg['total_population'].sum()),\n    \"population_high_risk\": int(census_bg['pop_high_risk'].sum()),\n    \"population_moderate_risk\": int(census_bg['pop_moderate_risk'].sum()),\n    \"population_low_risk\": int(census_bg['pop_low_risk'].sum()),\n    \"percent_high_risk\": round((census_bg['pop_high_risk'].sum() / census_bg['total_population'].sum()) * 100, 2),\n    \"block_groups_total\": len(census_bg),\n    \"mean_risk_score\": round(census_bg['weighted_risk_score'].mean(), 2),\n    \"median_risk_score\": round(census_bg['weighted_risk_score'].median(), 2),\n    \"area_high_risk_km2\": round(areas[2], 2),\n    \"area_moderate_risk_km2\": round(areas[1], 2),\n    \"area_low_risk_km2\": round(areas[0], 2),\n    \"top_5_highest_risk\": [\n        {\n            \"geoid\": row['GEOID'],\n            \"population\": int(row['total_population']),\n            \"risk_score\": round(row['weighted_risk_score'], 2),\n            \"percent_high_risk\": round(row['pct_high'], 1)\n        }\n        for _, row in census_bg.nlargest(5, 'weighted_risk_score').iterrows()\n    ]\n}\n\nwith open('outputs/data/summary_statistics.json', 'w') as f:\n    json.dump(summary_stats, f, indent=2)\n    \nprint(\"‚úì Summary statistics exported as JSON\")\n\n‚úì Simplified GeoJSON exported for web use\n‚úì Summary statistics exported as JSON\n\n\n\n# Create standalone legend graphics\nfig, axes = plt.subplots(1, 3, figsize=(15, 3))\n\n# Legend 1: Risk Categories\nax1 = axes[0]\nax1.axis('off')\ncolors_legend = ['lightgreen', 'orange', 'darkred']\nlabels_legend = ['Low Risk\\n(&gt;5m elevation, &gt;1km from water)', \n                 'Moderate Risk\\n(2-5m elevation, 500m-1km from water)', \n                 'High Risk\\n(&lt;2m elevation, &lt;100m from water)']\nfor i, (color, label) in enumerate(zip(colors_legend, labels_legend)):\n    ax1.add_patch(plt.Rectangle((0, 2-i*0.8), 0.3, 0.6, facecolor=color, edgecolor='black', linewidth=2))\n    ax1.text(0.4, 2-i*0.8+0.3, label, fontsize=11, va='center')\nax1.set_xlim(0, 3)\nax1.set_ylim(-0.5, 3)\nax1.set_title('Flood Risk Categories', fontsize=13, fontweight='bold')\n\n# Legend 2: Risk Score Scale\nax2 = axes[1]\nax2.axis('off')\ngradient = np.linspace(0, 1, 256).reshape(1, -1)\ngradient = np.vstack((gradient, gradient))\nax2.imshow(gradient, aspect='auto', cmap='RdYlGn_r', extent=[1, 3, 0, 1])\nax2.set_xlim(1, 3)\nax2.set_ylim(0, 1.5)\nax2.text(1, 1.2, '1.0', fontsize=10, ha='center', fontweight='bold')\nax2.text(2, 1.2, '2.0', fontsize=10, ha='center', fontweight='bold')\nax2.text(3, 1.2, '3.0', fontsize=10, ha='center', fontweight='bold')\nax2.text(2, -0.3, 'Weighted Risk Score', fontsize=11, ha='center', fontweight='bold')\nax2.set_title('Continuous Risk Score', fontsize=13, fontweight='bold')\n\n# Legend 3: Map Symbols\nax3 = axes[2]\nax3.axis('off')\nax3.plot([0, 0.3], [2.5, 2.5], 'b-', linewidth=2, label='Waterways')\nax3.plot([0, 0.3], [2, 2], color='darkblue', linewidth=3, label='Coastline')\nax3.plot([0, 0.3], [1.5, 1.5], 'k-', linewidth=3, label='County Boundary')\nax3.scatter([0.15], [1], color='red', s=200, marker='*', edgecolor='black', linewidth=2, label='High Risk Hotspot')\nfor i, (y, label) in enumerate([(2.5, 'Waterways'), (2, 'Coastline'), (1.5, 'County Boundary'), (1, 'High Risk Hotspot')]):\n    ax3.text(0.4, y, label, fontsize=11, va='center')\nax3.set_xlim(0, 2.5)\nax3.set_ylim(0.5, 3)\nax3.set_title('Map Symbols', fontsize=13, fontweight='bold')\n\nplt.tight_layout()\nplt.savefig('outputs/figures/12_legends.png', dpi=300, bbox_inches='tight')\nplt.show()\n\nprint(\"‚úì Legend graphics saved\")\n\n\n\n\n\n\n\n\n‚úì Legend graphics saved\n\n\n\n# Print comprehensive file checklist\nprint(\"=\"*70)\nprint(\"VISUALIZATION COMPLETE - FILE CHECKLIST\")\nprint(\"=\"*70)\n\nprint(\"\\nüìÅ OUTPUT FILES CREATED:\")\n\nprint(\"\\n  Interactive Maps:\")\nprint(\"    ‚úì outputs/maps/flood_risk_interactive_map.html\")\nprint(\"    ‚úì outputs/maps/census_risk_simplified.geojson\")\n\nprint(\"\\n  Static Figures:\")\nprint(\"    ‚úì outputs/figures/01_study_area.png\")\nprint(\"    ‚úì outputs/figures/02_all_processed_data.png\")\nprint(\"    ‚úì outputs/figures/03_elevation_risk.png\")\nprint(\"    ‚úì outputs/figures/04_water_buffers.png\")\nprint(\"    ‚úì outputs/figures/05_proximity_risk.png\")\nprint(\"    ‚úì outputs/figures/06_composite_flood_risk.png\")\nprint(\"    ‚úì outputs/figures/07_population_exposure_maps.png\")\nprint(\"    ‚úì outputs/figures/08_dominant_risk_categories.png\")\nprint(\"    ‚úì outputs/figures/09_statistical_analysis.png\")\nprint(\"    ‚úì outputs/figures/10_comprehensive_risk_map.png\")\nprint(\"    ‚úì outputs/figures/11_dashboard_summary.png\")\nprint(\"    ‚úì outputs/figures/12_legends.png\")\n\nprint(\"\\n  Processed Data:\")\nprint(\"    ‚úì data/processed/honolulu_boundary.shp\")\nprint(\"    ‚úì data/processed/waterways_honolulu.shp\")\nprint(\"    ‚úì data/processed/lines_honolulu.shp\")\nprint(\"    ‚úì data/processed/census_bg_honolulu.shp\")\nprint(\"    ‚úì data/processed/dem_honolulu.tif\")\nprint(\"    ‚úì data/processed/elevation_risk.tif\")\nprint(\"    ‚úì data/processed/proximity_risk.tif\")\nprint(\"    ‚úì data/processed/composite_risk.tif\")\nprint(\"    ‚úì data/processed/final_flood_risk.tif\")\nprint(\"    ‚úì data/processed/census_bg_with_risk.shp\")\nprint(\"    ‚úì data/processed/census_bg_with_risk.geojson\")\n\nprint(\"\\n  Data Tables:\")\nprint(\"    ‚úì outputs/data/population_risk_profile.csv\")\nprint(\"    ‚úì outputs/data/exposure_summary.csv\")\nprint(\"    ‚úì outputs/data/summary_statistics.json\")\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"‚úì ALL VISUALIZATIONS COMPLETE!\")\nprint(\"=\"*70)\n\n======================================================================\nVISUALIZATION COMPLETE - FILE CHECKLIST\n======================================================================\n\nüìÅ OUTPUT FILES CREATED:\n\n  Interactive Maps:\n    ‚úì outputs/maps/flood_risk_interactive_map.html\n    ‚úì outputs/maps/census_risk_simplified.geojson\n\n  Static Figures:\n    ‚úì outputs/figures/01_study_area.png\n    ‚úì outputs/figures/02_all_processed_data.png\n    ‚úì outputs/figures/03_elevation_risk.png\n    ‚úì outputs/figures/04_water_buffers.png\n    ‚úì outputs/figures/05_proximity_risk.png\n    ‚úì outputs/figures/06_composite_flood_risk.png\n    ‚úì outputs/figures/07_population_exposure_maps.png\n    ‚úì outputs/figures/08_dominant_risk_categories.png\n    ‚úì outputs/figures/09_statistical_analysis.png\n    ‚úì outputs/figures/10_comprehensive_risk_map.png\n    ‚úì outputs/figures/11_dashboard_summary.png\n    ‚úì outputs/figures/12_legends.png\n\n  Processed Data:\n    ‚úì data/processed/honolulu_boundary.shp\n    ‚úì data/processed/waterways_honolulu.shp\n    ‚úì data/processed/lines_honolulu.shp\n    ‚úì data/processed/census_bg_honolulu.shp\n    ‚úì data/processed/dem_honolulu.tif\n    ‚úì data/processed/elevation_risk.tif\n    ‚úì data/processed/proximity_risk.tif\n    ‚úì data/processed/composite_risk.tif\n    ‚úì data/processed/final_flood_risk.tif\n    ‚úì data/processed/census_bg_with_risk.shp\n    ‚úì data/processed/census_bg_with_risk.geojson\n\n  Data Tables:\n    ‚úì outputs/data/population_risk_profile.csv\n    ‚úì outputs/data/exposure_summary.csv\n    ‚úì outputs/data/summary_statistics.json\n\n======================================================================\n‚úì ALL VISUALIZATIONS COMPLETE!\n======================================================================"
  },
  {
    "objectID": "script/02_flood_risk_modeling.html",
    "href": "script/02_flood_risk_modeling.html",
    "title": "High Tide Ahead",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport rasterio\nfrom rasterio.features import rasterize\nfrom rasterio.windows import Window\nfrom rasterio.enums import Resampling\nfrom scipy.ndimage import distance_transform_edt\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\nfrom pathlib import Path\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Configuration\nCONFIG = {\n    # File paths\n    'dem_path': 'data/processed/dem_honolulu.tif',\n    'waterways_path': 'data/processed/waterways_honolulu.shp',\n    'coastline_path': 'data/processed/lines_honolulu.shp',  # NOT used for proximity\n    'boundary_path': 'data/processed/honolulu_boundary.shp',\n    'census_path': 'data/processed/census_bg_honolulu.shp',\n    'output_dir': 'data/processed',\n    'figures_dir': 'outputs/figures',\n    \n    # Processing parameters\n    'target_resolution': 10,  # meters - higher res than before\n    'chunk_size': 2048,       # pixels per chunk (tuned for 16GB RAM)\n    \n    # Model parameters\n    'elevation_weight': 0.70,  # 70% weight to elevation\n    'proximity_weight': 0.30,  # 30% weight to proximity\n    \n    # Elevation thresholds (meters)\n    'elev_high_risk': 3,      # &lt; 3m = high risk\n    'elev_mod_risk': 8,       # 3-8m = moderate risk\n                              # &gt; 8m = low risk\n    \n    # Proximity thresholds (meters from inland waterways)\n    'prox_high_risk': 100,    # &lt; 100m = high risk  \n    'prox_mod_risk': 500,     # 100-500m = moderate risk\n                              # &gt; 500m = low risk\n}\n\n# Create output directories\nPath(CONFIG['output_dir']).mkdir(parents=True, exist_ok=True)\nPath(CONFIG['figures_dir']).mkdir(parents=True, exist_ok=True)\n\nprint(\"‚úì Configuration loaded\")\nprint(f\"  Target resolution: {CONFIG['target_resolution']}m\")\nprint(f\"  Weighting: {CONFIG['elevation_weight']*100:.0f}% elevation, {CONFIG['proximity_weight']*100:.0f}% proximity\")\n\n‚úì Configuration loaded\n  Target resolution: 10m\n  Weighting: 70% elevation, 30% proximity\n\n\n\n\nprint(\"Loading vector data...\")\n\n# Load boundary\nhonolulu = gpd.read_file(CONFIG['boundary_path'])\nprint(f\"‚úì Honolulu boundary loaded\")\n\n# Load INLAND WATERWAYS ONLY (streams, rivers - NOT coastline)\nwaterways = gpd.read_file(CONFIG['waterways_path'])\nprint(f\"‚úì Inland waterways loaded: {len(waterways)} features\")\nprint(f\"  Total stream length: {waterways.length.sum()/1000:.1f} km\")\n\n# Load coastline (for reference/visualization only, NOT for proximity)\ncoastline = gpd.read_file(CONFIG['coastline_path'])\nprint(f\"‚úì Coastline loaded: {len(coastline)} features (NOT used for proximity)\")\n\n# Load census block groups\ncensus_bg = gpd.read_file(CONFIG['census_path'])\nprint(f\"‚úì Census block groups loaded: {len(census_bg)} features\")\n\n# Get DEM metadata for reference\nwith rasterio.open(CONFIG['dem_path']) as src:\n    dem_crs = src.crs\n    dem_bounds = src.bounds\n    dem_res = src.res[0]\n    dem_shape = src.shape\n    dem_transform = src.transform\n    dem_meta = src.meta.copy()\n    \nprint(f\"\\n‚úì DEM metadata loaded:\")\nprint(f\"  Shape: {dem_shape[0]} √ó {dem_shape[1]} pixels\")\nprint(f\"  Resolution: {dem_res:.2f}m\")\nprint(f\"  CRS: {dem_crs}\")\n\nLoading vector data...\n‚úì Honolulu boundary loaded\n‚úì Inland waterways loaded: 2340 features\n  Total stream length: 7849.1 km\n‚úì Coastline loaded: 4 features (NOT used for proximity)\n‚úì Census block groups loaded: 774 features\n\n‚úì DEM metadata loaded:\n  Shape: 52758 √ó 67740 pixels\n  Resolution: 3.28m\n  CRS: EPSG:3759\n\n\n\n\nprint(f\"Creating {CONFIG['target_resolution']}m resolution working raster...\")\n\n# Calculate new dimensions for target resolution\nscale_factor = dem_res / CONFIG['target_resolution']\n\nif scale_factor &lt; 1:\n    new_height = int(dem_shape[0] * scale_factor)\n    new_width = int(dem_shape[1] * scale_factor)\n    print(f\"  Upsampling from {dem_res:.1f}m to {CONFIG['target_resolution']}m\")\nelse:\n    new_height = int(dem_shape[0] / scale_factor)\n    new_width = int(dem_shape[1] / scale_factor)\n    print(f\"  Downsampling from {dem_res:.1f}m to {CONFIG['target_resolution']}m\")\n\n# Read DEM at target resolution\nwith rasterio.open(CONFIG['dem_path']) as src:\n    dem = src.read(\n        1,\n        out_shape=(new_height, new_width),\n        resampling=Resampling.bilinear\n    )\n    \n    # Calculate new transform\n    new_transform = src.transform * src.transform.scale(\n        src.width / new_width,\n        src.height / new_height\n    )\n\n# Handle nodata\nnodata_val = dem_meta.get('nodata', -9999)\ndem = np.where(dem == nodata_val, np.nan, dem)\ndem = np.where(dem &lt; -100, np.nan, dem)\n\n# Calculate memory usage\nmem_mb = dem.nbytes / (1024 * 1024)\nprint(f\"\\n‚úì DEM loaded at working resolution\")\nprint(f\"  Shape: {dem.shape[0]} √ó {dem.shape[1]} pixels\")\nprint(f\"  Actual resolution: {new_transform[0]:.2f}m\")\nprint(f\"  Memory usage: {mem_mb:.1f} MB\")\nprint(f\"  Valid pixels: {np.sum(~np.isnan(dem)):,} ({np.sum(~np.isnan(dem))/dem.size*100:.1f}%)\")\nprint(f\"  Elevation range: {np.nanmin(dem):.1f}m to {np.nanmax(dem):.1f}m\")\n\n# Store working metadata\nworking_meta = dem_meta.copy()\nworking_meta.update({\n    'height': new_height,\n    'width': new_width,\n    'transform': new_transform,\n    'dtype': 'float32'\n})\n\nCreating 10m resolution working raster...\n  Upsampling from 3.3m to 10m\n\n‚úì DEM loaded at working resolution\n  Shape: 17313 √ó 22229 pixels\n  Actual resolution: 10.00m\n  Memory usage: 1468.1 MB\n  Valid pixels: 148,162,755 (38.5%)\n  Elevation range: -83.1m to 1216.8m\n\n\n\n\nprint(\"Classifying elevation-based flood risk...\")\n\ndef classify_elevation_risk(elev_array, high_thresh, mod_thresh):\n    \"\"\"\n    Classify elevation into flood risk categories.\n    LOW elevation = HIGH flood risk\n    HIGH elevation = LOW flood risk\n    \"\"\"\n    risk = np.zeros_like(elev_array, dtype=np.uint8)\n    \n    # High risk: below high threshold (closest to sea level)\n    risk[elev_array &lt; high_thresh] = 3\n    \n    # Moderate risk: between thresholds\n    risk[(elev_array &gt;= high_thresh) & (elev_array &lt; mod_thresh)] = 2\n    \n    # Low risk: above moderate threshold\n    risk[elev_array &gt;= mod_thresh] = 1\n    \n    # No data\n    risk[np.isnan(elev_array)] = 0\n    \n    return risk\n\nelevation_risk = classify_elevation_risk(\n    dem, \n    CONFIG['elev_high_risk'], \n    CONFIG['elev_mod_risk']\n)\n\n# Statistics\nvalid_pixels = np.sum(elevation_risk &gt; 0)\nhigh_pct = np.sum(elevation_risk == 3) / valid_pixels * 100\nmod_pct = np.sum(elevation_risk == 2) / valid_pixels * 100\nlow_pct = np.sum(elevation_risk == 1) / valid_pixels * 100\n\nprint(f\"\\n‚úì Elevation risk classification complete\")\nprint(f\"  Thresholds: High risk &lt; {CONFIG['elev_high_risk']}m, Moderate &lt; {CONFIG['elev_mod_risk']}m\")\nprint(f\"\\n  Distribution:\")\nprint(f\"    High risk (coastal):    {np.sum(elevation_risk == 3):&gt;10,} pixels ({high_pct:&gt;5.1f}%)\")\nprint(f\"    Moderate risk:          {np.sum(elevation_risk == 2):&gt;10,} pixels ({mod_pct:&gt;5.1f}%)\")\nprint(f\"    Low risk (elevated):    {np.sum(elevation_risk == 1):&gt;10,} pixels ({low_pct:&gt;5.1f}%)\")\nprint(f\"    No data:                {np.sum(elevation_risk == 0):&gt;10,} pixels\")\n\nClassifying elevation-based flood risk...\n\n‚úì Elevation risk classification complete\n  Thresholds: High risk &lt; 3m, Moderate &lt; 8m\n\n  Distribution:\n    High risk (coastal):    42,115,314 pixels ( 28.4%)\n    Moderate risk:          10,918,984 pixels (  7.4%)\n    Low risk (elevated):    95,128,457 pixels ( 64.2%)\n    No data:                236,687,922 pixels\n\n\n\n\nprint(\"Calculating proximity to inland waterways...\")\nprint(\"  NOTE: Using ONLY streams/rivers, NOT coastline\")\n\n# Rasterize waterways to binary mask\nwaterway_shapes = [(geom, 1) for geom in waterways.geometry]\n\nwaterway_mask = rasterize(\n    waterway_shapes,\n    out_shape=(new_height, new_width),\n    transform=new_transform,\n    fill=0,\n    dtype=np.uint8,\n    all_touched=True\n)\n\nprint(f\"  Waterway pixels: {np.sum(waterway_mask &gt; 0):,}\")\n\n# Calculate Euclidean distance transform\ndistance_pixels = distance_transform_edt(waterway_mask == 0)\ndistance_meters = distance_pixels * CONFIG['target_resolution']\n\nprint(f\"  Distance range: {distance_meters.min():.0f}m to {distance_meters.max():.0f}m\")\nprint(f\"  Mean distance: {np.nanmean(distance_meters):.0f}m\")\n\n# Classify into risk categories\ndef classify_proximity_risk(dist_array, high_thresh, mod_thresh):\n    \"\"\"\n    Classify proximity to waterways into flood risk categories.\n    CLOSE to waterways = HIGH risk\n    FAR from waterways = LOW risk\n    \"\"\"\n    risk = np.ones_like(dist_array, dtype=np.uint8)  # Default to low risk\n    \n    # High risk: very close to waterways\n    risk[dist_array &lt; high_thresh] = 3\n    \n    # Moderate risk: intermediate distance\n    risk[(dist_array &gt;= high_thresh) & (dist_array &lt; mod_thresh)] = 2\n    \n    return risk\n\nproximity_risk = classify_proximity_risk(\n    distance_meters,\n    CONFIG['prox_high_risk'],\n    CONFIG['prox_mod_risk']\n)\n\n# Apply nodata mask from DEM\nproximity_risk[np.isnan(dem)] = 0\n\n# Statistics\nvalid_pixels = np.sum(proximity_risk &gt; 0)\nhigh_pct = np.sum(proximity_risk == 3) / valid_pixels * 100\nmod_pct = np.sum(proximity_risk == 2) / valid_pixels * 100\nlow_pct = np.sum(proximity_risk == 1) / valid_pixels * 100\n\nprint(f\"\\n‚úì Proximity risk classification complete\")\nprint(f\"  Thresholds: High risk &lt; {CONFIG['prox_high_risk']}m, Moderate &lt; {CONFIG['prox_mod_risk']}m\")\nprint(f\"\\n  Distribution:\")\nprint(f\"    High risk (near water): {np.sum(proximity_risk == 3):&gt;10,} pixels ({high_pct:&gt;5.1f}%)\")\nprint(f\"    Moderate risk:          {np.sum(proximity_risk == 2):&gt;10,} pixels ({mod_pct:&gt;5.1f}%)\")\nprint(f\"    Low risk (far):         {np.sum(proximity_risk == 1):&gt;10,} pixels ({low_pct:&gt;5.1f}%)\")\n\nCalculating proximity to inland waterways...\n  NOTE: Using ONLY streams/rivers, NOT coastline\n  Waterway pixels: 992,894\n  Distance range: 0m to 95129m\n  Mean distance: 14533m\n\n‚úì Proximity risk classification complete\n  Thresholds: High risk &lt; 100m, Moderate &lt; 500m\n\n  Distribution:\n    High risk (near water):  8,640,313 pixels (  5.8%)\n    Moderate risk:          29,929,507 pixels ( 20.2%)\n    Low risk (far):         109,592,935 pixels ( 74.0%)\n\n\n\n\nprint(\"Creating composite flood risk score...\")\nprint(f\"  Weights: {CONFIG['elevation_weight']*100:.0f}% elevation, {CONFIG['proximity_weight']*100:.0f}% proximity\")\n\n# Create weighted composite (continuous score)\ncomposite_continuous = (\n    CONFIG['elevation_weight'] * elevation_risk.astype(float) +\n    CONFIG['proximity_weight'] * proximity_risk.astype(float)\n)\n\n# Handle nodata\ncomposite_continuous[elevation_risk == 0] = np.nan\n\nprint(f\"  Composite score range: {np.nanmin(composite_continuous):.2f} to {np.nanmax(composite_continuous):.2f}\")\n\n# Classify composite into final risk categories\ndef classify_composite_risk(composite_array):\n    \"\"\"\n    Classify weighted composite score into final risk categories.\n    \"\"\"\n    risk = np.zeros_like(composite_array, dtype=np.uint8)\n    \n    # Low risk\n    risk[composite_array &lt; 1.5] = 1\n    \n    # Moderate risk\n    risk[(composite_array &gt;= 1.5) & (composite_array &lt; 2.3)] = 2\n    \n    # High risk\n    risk[composite_array &gt;= 2.3] = 3\n    \n    # No data\n    risk[np.isnan(composite_array)] = 0\n    \n    return risk\n\nfinal_flood_risk = classify_composite_risk(composite_continuous)\n\n# Statistics\nvalid_pixels = np.sum(final_flood_risk &gt; 0)\npixel_area_m2 = CONFIG['target_resolution'] ** 2\npixel_area_km2 = pixel_area_m2 / 1e6\n\nprint(f\"\\n‚úì Final flood risk classification complete\")\nprint(f\"\\n  Distribution:\")\nfor risk_level, label in [(3, 'High'), (2, 'Moderate'), (1, 'Low')]:\n    count = np.sum(final_flood_risk == risk_level)\n    pct = count / valid_pixels * 100\n    area = count * pixel_area_km2\n    print(f\"    {label:12} risk: {count:&gt;10,} pixels ({pct:&gt;5.1f}%) = {area:&gt;6.1f} km¬≤\")\n\ntotal_area = valid_pixels * pixel_area_km2\nprint(f\"\\n  Total analyzed area: {total_area:.1f} km¬≤\")\n\nCreating composite flood risk score...\n  Weights: 70% elevation, 30% proximity\n  Composite score range: 1.00 to 3.00\n\n‚úì Final flood risk classification complete\n\n  Distribution:\n    High         risk: 42,627,644 pixels ( 28.8%) = 4262.8 km¬≤\n    Moderate     risk: 18,035,316 pixels ( 12.2%) = 1803.5 km¬≤\n    Low          risk: 87,499,795 pixels ( 59.1%) = 8750.0 km¬≤\n\n  Total analyzed area: 14816.3 km¬≤\n\n\n\n\nprint(\"Creating visualization...\")\n\nfig, axes = plt.subplots(2, 2, figsize=(16, 14))\n\n# Color maps\nrisk_colors = ['#f0f0f0', '#2ecc71', '#f39c12', '#e74c3c']\nrisk_cmap = ListedColormap(risk_colors)\nrisk_norm = BoundaryNorm([0, 0.5, 1.5, 2.5, 3.5], risk_cmap.N)\n\n# Panel A: Elevation\nim1 = axes[0, 0].imshow(dem, cmap='terrain', vmin=0, vmax=100)\naxes[0, 0].set_title('(A) Digital Elevation Model', fontsize=14, fontweight='bold')\naxes[0, 0].axis('off')\ncbar1 = plt.colorbar(im1, ax=axes[0, 0], fraction=0.046, pad=0.04)\ncbar1.set_label('Elevation (m)', fontsize=11)\n\n# Panel B: Elevation Risk\nim2 = axes[0, 1].imshow(elevation_risk, cmap=risk_cmap, norm=risk_norm)\naxes[0, 1].set_title(f'(B) Elevation Risk (weight: {CONFIG[\"elevation_weight\"]*100:.0f}%)', \n                     fontsize=14, fontweight='bold')\naxes[0, 1].axis('off')\ncbar2 = plt.colorbar(im2, ax=axes[0, 1], fraction=0.046, pad=0.04, ticks=[0.5, 1, 2, 3])\ncbar2.ax.set_yticklabels(['No Data', f'Low (&gt;{CONFIG[\"elev_mod_risk\"]}m)', \n                          f'Mod ({CONFIG[\"elev_high_risk\"]}-{CONFIG[\"elev_mod_risk\"]}m)', \n                          f'High (&lt;{CONFIG[\"elev_high_risk\"]}m)'])\n\n# Panel C: Proximity Risk\nim3 = axes[1, 0].imshow(proximity_risk, cmap=risk_cmap, norm=risk_norm)\naxes[1, 0].set_title(f'(C) Proximity Risk - Inland Waterways Only (weight: {CONFIG[\"proximity_weight\"]*100:.0f}%)', \n                     fontsize=14, fontweight='bold')\naxes[1, 0].axis('off')\ncbar3 = plt.colorbar(im3, ax=axes[1, 0], fraction=0.046, pad=0.04, ticks=[0.5, 1, 2, 3])\ncbar3.ax.set_yticklabels(['No Data', f'Low (&gt;{CONFIG[\"prox_mod_risk\"]}m)', \n                          f'Mod ({CONFIG[\"prox_high_risk\"]}-{CONFIG[\"prox_mod_risk\"]}m)', \n                          f'High (&lt;{CONFIG[\"prox_high_risk\"]}m)'])\n\n# Panel D: Final Composite Risk\nim4 = axes[1, 1].imshow(final_flood_risk, cmap=risk_cmap, norm=risk_norm)\naxes[1, 1].set_title('(D) Final Composite Flood Risk', fontsize=14, fontweight='bold')\naxes[1, 1].axis('off')\ncbar4 = plt.colorbar(im4, ax=axes[1, 1], fraction=0.046, pad=0.04, ticks=[0.5, 1, 2, 3])\ncbar4.ax.set_yticklabels(['No Data', 'Low', 'Moderate', 'High'])\n\nplt.suptitle('Flood Risk Model Components - Oahu, Honolulu County\\n' +\n             f'Resolution: {CONFIG[\"target_resolution\"]}m | ' +\n             f'Weights: {CONFIG[\"elevation_weight\"]*100:.0f}% elevation, {CONFIG[\"proximity_weight\"]*100:.0f}% proximity',\n             fontsize=16, fontweight='bold', y=1.02)\n\nplt.tight_layout()\nplt.savefig(f'{CONFIG[\"figures_dir\"]}/flood_risk_components.png', dpi=300, bbox_inches='tight')\nplt.show()\n\nprint(f\"‚úì Saved: {CONFIG['figures_dir']}/flood_risk_components.png\")\n\nCreating visualization...\n\n\n\n\n\n\n\n\n\n‚úì Saved: outputs/figures/flood_risk_components.png\n\n\n\n\nprint(\"Creating waterway distance visualization...\")\n\nfig, axes = plt.subplots(1, 2, figsize=(16, 7))\n\n# Panel A: Distance to waterways (continuous)\ndist_display = np.clip(distance_meters, 0, 2000)\ndist_display[np.isnan(dem)] = np.nan\n\nim1 = axes[0].imshow(dist_display, cmap='Blues_r', vmin=0, vmax=2000)\naxes[0].set_title('(A) Distance to Inland Waterways', fontsize=14, fontweight='bold')\naxes[0].axis('off')\ncbar1 = plt.colorbar(im1, ax=axes[0], fraction=0.046, pad=0.04)\ncbar1.set_label('Distance (m)', fontsize=11)\n\n# Panel B: Waterway network overlay\naxes[1].imshow(dem, cmap='terrain', alpha=0.5, vmin=0, vmax=100)\nwaterway_display = np.ma.masked_where(waterway_mask == 0, waterway_mask)\naxes[1].imshow(waterway_display, cmap='Blues', alpha=0.8)\naxes[1].set_title('(B) Inland Waterway Network (streams/rivers)', fontsize=14, fontweight='bold')\naxes[1].axis('off')\n\nplt.suptitle('Proximity Analysis - Inland Waterways Only\\n(Coastline excluded from proximity calculation)',\n             fontsize=14, fontweight='bold', y=1.02)\n\nplt.tight_layout()\nplt.savefig(f'{CONFIG[\"figures_dir\"]}/waterway_distance.png', dpi=300, bbox_inches='tight')\nplt.show()\n\nprint(f\"‚úì Saved: {CONFIG['figures_dir']}/waterway_distance.png\")\n\nCreating waterway distance visualization...\n\n\n\n\n\n\n\n\n\n‚úì Saved: outputs/figures/waterway_distance.png\n\n\n\n\nprint(\"Saving risk rasters...\")\n\n# Update metadata for output\noutput_meta = working_meta.copy()\noutput_meta.update({\n    'dtype': 'uint8',\n    'nodata': 0\n})\n\n# Save elevation risk\noutput_path = f'{CONFIG[\"output_dir\"]}/elevation_risk.tif'\nwith rasterio.open(output_path, 'w', **output_meta) as dst:\n    dst.write(elevation_risk, 1)\nprint(f\"‚úì Saved: {output_path}\")\n\n# Save proximity risk\noutput_path = f'{CONFIG[\"output_dir\"]}/proximity_risk.tif'\nwith rasterio.open(output_path, 'w', **output_meta) as dst:\n    dst.write(proximity_risk, 1)\nprint(f\"‚úì Saved: {output_path}\")\n\n# Save distance to waterways (continuous)\ndist_meta = working_meta.copy()\ndist_meta.update({\n    'dtype': 'float32',\n    'nodata': -9999\n})\noutput_path = f'{CONFIG[\"output_dir\"]}/waterway_distance.tif'\ndist_output = np.where(np.isnan(dem), -9999, distance_meters)\nwith rasterio.open(output_path, 'w', **dist_meta) as dst:\n    dst.write(dist_output.astype('float32'), 1)\nprint(f\"‚úì Saved: {output_path}\")\n\n# Save composite score (continuous)\noutput_path = f'{CONFIG[\"output_dir\"]}/composite_risk_continuous.tif'\ncomposite_output = np.where(np.isnan(composite_continuous), -9999, composite_continuous)\nwith rasterio.open(output_path, 'w', **dist_meta) as dst:\n    dst.write(composite_output.astype('float32'), 1)\nprint(f\"‚úì Saved: {output_path}\")\n\n# Save final flood risk (categorical)\noutput_path = f'{CONFIG[\"output_dir\"]}/final_flood_risk.tif'\nwith rasterio.open(output_path, 'w', **output_meta) as dst:\n    dst.write(final_flood_risk, 1)\nprint(f\"‚úì Saved: {output_path}\")\n\nprint(\"\\n‚úì All risk rasters saved to data/processed/\")\n\nSaving risk rasters...\n‚úì Saved: data/processed/elevation_risk.tif\n‚úì Saved: data/processed/proximity_risk.tif\n‚úì Saved: data/processed/waterway_distance.tif\n‚úì Saved: data/processed/composite_risk_continuous.tif\n‚úì Saved: data/processed/final_flood_risk.tif\n\n‚úì All risk rasters saved to data/processed/\n\n\n\n\nprint(\"=\" * 70)\nprint(\"FLOOD RISK MODELING SUMMARY\")\nprint(\"=\" * 70)\n\nprint(f\"\\n Model Configuration:\")\nprint(f\"   Resolution: {CONFIG['target_resolution']}m\")\nprint(f\"   Elevation weight: {CONFIG['elevation_weight']*100:.0f}%\")\nprint(f\"   Proximity weight: {CONFIG['proximity_weight']*100:.0f}%\")\n\nprint(f\"\\n Elevation Thresholds:\")\nprint(f\"   High risk: &lt; {CONFIG['elev_high_risk']}m\")\nprint(f\"   Moderate risk: {CONFIG['elev_high_risk']}-{CONFIG['elev_mod_risk']}m\")\nprint(f\"   Low risk: &gt; {CONFIG['elev_mod_risk']}m\")\n\nprint(f\"\\n Proximity Thresholds (inland waterways only):\")\nprint(f\"   High risk: &lt; {CONFIG['prox_high_risk']}m from stream/river\")\nprint(f\"   Moderate risk: {CONFIG['prox_high_risk']}-{CONFIG['prox_mod_risk']}m\")\nprint(f\"   Low risk: &gt; {CONFIG['prox_mod_risk']}m\")\n\nprint(f\"\\n Final Risk Distribution:\")\nvalid_pixels = np.sum(final_flood_risk &gt; 0)\nfor risk_level, label, color in [(3, 'High', 'üî¥'), (2, 'Moderate', 'üü†'), (1, 'Low', 'üü¢')]:\n    count = np.sum(final_flood_risk == risk_level)\n    pct = count / valid_pixels * 100\n    area = count * pixel_area_km2\n    print(f\"   {color} {label:12}: {pct:&gt;5.1f}% ({area:&gt;6.1f} km¬≤)\")\n\nprint(f\"\\n   Total analyzed area: {valid_pixels * pixel_area_km2:.1f} km¬≤\")\n\nprint(f\"\\n Output Files:\")\nprint(f\"   - elevation_risk.tif\")\nprint(f\"   - proximity_risk.tif\") \nprint(f\"   - waterway_distance.tif\")\nprint(f\"   - composite_risk_continuous.tif\")\nprint(f\"   - final_flood_risk.tif\")\n\nprint(\"\\n\" + \"=\" * 70)\nprint(\"‚úì Flood risk modeling complete!\")\nprint(\"  ‚Üí Proceed to notebook 03 for population exposure analysis\")\nprint(\"=\" * 70)\n\n======================================================================\nFLOOD RISK MODELING SUMMARY\n======================================================================\n\nüìä Model Configuration:\n   Resolution: 10m\n   Elevation weight: 70%\n   Proximity weight: 30%\n\n‚õ∞Ô∏è Elevation Thresholds:\n   High risk: &lt; 3m\n   Moderate risk: 3-8m\n   Low risk: &gt; 8m\n\nüåä Proximity Thresholds (inland waterways only):\n   High risk: &lt; 100m from stream/river\n   Moderate risk: 100-500m\n   Low risk: &gt; 500m\n\nüìà Final Risk Distribution:\n   üî¥ High        :  28.8% (4262.8 km¬≤)\n   üü† Moderate    :  12.2% (1803.5 km¬≤)\n   üü¢ Low         :  59.1% (8750.0 km¬≤)\n\n   Total analyzed area: 14816.3 km¬≤\n\nüìÅ Output Files:\n   - elevation_risk.tif\n   - proximity_risk.tif\n   - waterway_distance.tif\n   - composite_risk_continuous.tif\n   - final_flood_risk.tif\n\n======================================================================\n‚úì Flood risk modeling complete!\n  ‚Üí Proceed to notebook 03 for population exposure analysis\n======================================================================"
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Results",
    "section": "",
    "text": "The flood risk model combines elevation and proximity to inland waterways, weighted 70% and 30% respectively.\n\n\n\nFlood Risk Model Components\n\n\nPanel (A) shows the digital elevation model, with the Ko‚Äôolau and Wai‚Äôanae mountain ranges clearly visible. Panel (B) classifies elevation into risk categories. Panel (C) shows proximity risk based on distance to streams and rivers (coastline excluded). Panel (D) presents the final composite risk classification."
  },
  {
    "objectID": "results.html#risk-model-components",
    "href": "results.html#risk-model-components",
    "title": "Results",
    "section": "",
    "text": "The flood risk model combines elevation and proximity to inland waterways, weighted 70% and 30% respectively.\n\n\n\nFlood Risk Model Components\n\n\nPanel (A) shows the digital elevation model, with the Ko‚Äôolau and Wai‚Äôanae mountain ranges clearly visible. Panel (B) classifies elevation into risk categories. Panel (C) shows proximity risk based on distance to streams and rivers (coastline excluded). Panel (D) presents the final composite risk classification."
  },
  {
    "objectID": "results.html#comprehensive-risk-map",
    "href": "results.html#comprehensive-risk-map",
    "title": "Results",
    "section": "Comprehensive Risk Map",
    "text": "Comprehensive Risk Map\n\n\n\nComprehensive Flood Risk Assessment\n\n\nThe top 5 highest-risk block groups are marked with stars. High-risk areas concentrate along the southern coastal plain (Waikiki, Ala Moana, Pearl Harbor) and in windward valley floors."
  },
  {
    "objectID": "results.html#population-exposure",
    "href": "results.html#population-exposure",
    "title": "Results",
    "section": "Population Exposure",
    "text": "Population Exposure\n\n\n\nPopulation Flood Risk Exposure Analysis\n\n\n\n\n\n\n\n\nNoteData Note\n\n\n\nThe figures and statistics below are for Oahu only. Honolulu County technically includes small Northwestern Hawaiian Islands, which were filtered out during visualization. The raw CSV files in the repository contain data for all of Honolulu County (773 block groups, 979,682 residents), while the figures shown here are subsetted to Oahu (703 block groups, 886,849 residents).\n\n\n\nBy Population (Oahu Only)\n\n\n\nRisk Category\nPopulation\nPercent\n\n\n\n\nHigh\n86,462\n9.7%\n\n\nModerate\n142,190\n16.0%\n\n\nLow\n632,045\n71.3%\n\n\nTotal\n886,849\n100%\n\n\n\n\n\nBy Land Area\n\n\n\nRisk Category\nPercent of Land\n\n\n\n\nHigh\n28.8%\n\n\nModerate\n12.2%\n\n\nLow\n59.1%\n\n\n\nThe disparity between land area and population percentages reflects that high-risk coastal areas tend to be less densely populated than inland urban zones."
  },
  {
    "objectID": "results.html#dashboard-summary",
    "href": "results.html#dashboard-summary",
    "title": "Results",
    "section": "Dashboard Summary",
    "text": "Dashboard Summary\n\n\n\nFlood Risk Dashboard\n\n\n\nKey Statistics (Oahu Only)\n\nTotal Population Analyzed: 886,849\nHigh Risk Exposure: 86,462 (9.7%)\nBlock Groups Analyzed: 703\nMean Risk Score: 1.37 / 3.0"
  },
  {
    "objectID": "results.html#top-high-risk-areas",
    "href": "results.html#top-high-risk-areas",
    "title": "Results",
    "section": "Top High-Risk Areas",
    "text": "Top High-Risk Areas\nThe following census block groups have the highest composite risk scores:\n\n\n\nRank\nBlock Group\nPopulation\nRisk Score\n\n\n\n\n1\n900010\n0\n3.00\n\n\n2\n037034\n0\n2.83\n\n\n3\n001083\n1,296\n2.82\n\n\n4\n802001\n537\n2.80\n\n\n5\n012022\n1,104\n2.75\n\n\n\nNote: Block groups with zero population are typically parks, industrial areas, or military installations."
  },
  {
    "objectID": "results.html#legend-reference",
    "href": "results.html#legend-reference",
    "title": "Results",
    "section": "Legend Reference",
    "text": "Legend Reference\n\n\n\nMap Legend"
  },
  {
    "objectID": "results.html#interactive-exploration",
    "href": "results.html#interactive-exploration",
    "title": "Results",
    "section": "Interactive Exploration",
    "text": "Interactive Exploration\nThe interactive map allows detailed exploration of flood risk across Oahu. Features include:\n\nToggle layers: Switch between risk score and population exposure views\nClick for details: View block group statistics in popup windows\nHigh-risk markers: Top 10 highest-risk block groups marked with warning icons"
  },
  {
    "objectID": "results.html#key-takeaways",
    "href": "results.html#key-takeaways",
    "title": "Results",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\n\n\n\n\n\nImportantSummary Findings (Oahu Only)\n\n\n\n\n86,462 residents (9.7% of Oahu‚Äôs population) live in high flood risk areas\nHigh-risk areas concentrate along the southern coastal plain and windward valley floors\nThe elevation component drives most of the risk classification on this island geography\nStream proximity adds localized high-risk corridors inland from the coast\nMean risk score of 1.37 indicates most block groups are relatively low-risk"
  },
  {
    "objectID": "results.html#limitations",
    "href": "results.html#limitations",
    "title": "Results",
    "section": "Limitations",
    "text": "Limitations\nSeveral factors affect interpretation of these results:\n\nUniform population assumption: Population is allocated proportionally by area, not actual residential density\nStatic analysis: Does not account for future sea level rise or development changes\nNo storm modeling: Risk categories are based on physical exposure, not probabilistic flood modeling\nResolution tradeoffs: 10m resolution balances detail with computational feasibility\n\nSee Methodology for additional technical details."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "High Tide Ahead",
    "section": "Overview",
    "text": "Overview\nOahu, the most populous island in Honolulu County, faces significant flood risk from multiple sources: coastal inundation, storm surge, and riverine flooding from the island‚Äôs numerous streams and waterways. This analysis develops a composite flood risk model for Oahu and estimates population exposure across approximately 887,000 residents.\nThe project combines elevation data, hydrological features, and demographic information to identify flood-prone areas and quantify who lives in harm‚Äôs way."
  },
  {
    "objectID": "index.html#key-findings",
    "href": "index.html#key-findings",
    "title": "High Tide Ahead",
    "section": "Key Findings",
    "text": "Key Findings\n\n\n86,462\n\nResidents in High-Risk Areas (9.7%) Living below 3m elevation or within 100m of inland waterways\n\n\n\n142,190\n\nResidents in Moderate-Risk Areas (16.0%) Elevation 3-8m or within 100-500m of waterways\n\n\n\n632,045\n\nResidents in Low-Risk Areas (71.3%) Above 8m elevation and more than 500m from waterways\n\nNote: Statistics above are for Oahu only. Honolulu County also includes small Northwestern Hawaiian Islands, which are excluded from this analysis."
  },
  {
    "objectID": "index.html#study-area",
    "href": "index.html#study-area",
    "title": "High Tide Ahead",
    "section": "Study Area",
    "text": "Study Area\nOahu is the most populous of the Hawaiian Islands, home to Honolulu and roughly two-thirds of the state‚Äôs population. The island‚Äôs geography presents unique flood risk challenges:\n\nCoastal exposure: The entire island perimeter faces potential storm surge and sea level rise impacts\nSteep terrain: Rainfall rapidly concentrates in streams that can flash flood\nDense development: Urban Honolulu concentrates population in low-lying coastal areas\nLimited escape routes: Island geography constrains evacuation options\n\n\n\n\nFlood Risk Model Components"
  },
  {
    "objectID": "index.html#interactive-map",
    "href": "index.html#interactive-map",
    "title": "High Tide Ahead",
    "section": "Interactive Map",
    "text": "Interactive Map\nExplore flood risk across Oahu‚Äôs census block groups. Toggle layers to view risk scores, population exposure, and water features."
  },
  {
    "objectID": "index.html#project-summary",
    "href": "index.html#project-summary",
    "title": "High Tide Ahead",
    "section": "Project Summary",
    "text": "Project Summary\n\n\n\nComponent\nDescription\n\n\n\n\nStudy Area\nOahu, Honolulu County (703 census block groups)\n\n\nPopulation\n886,849 residents\n\n\nResolution\n10m grid cells\n\n\nRisk Factors\nElevation (70%), Proximity to waterways (30%)\n\n\nData Sources\nUSGS 3DEP, USGS NHD, Census TIGER/ACS"
  },
  {
    "objectID": "index.html#navigation",
    "href": "index.html#navigation",
    "title": "High Tide Ahead",
    "section": "Navigation",
    "text": "Navigation\n\nMethodology: Data sources, processing steps, and model design\nResults: Maps, statistics, and key findings\nAbout: Project context and acknowledgments"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This analysis was developed as the final project for MUSA 5500: Geospatial Data Science in Python at the University of Pennsylvania Weitzman School of Design.\nThe project demonstrates proficiency in:\n\nRaster analysis and terrain processing\nIntegration of multiple geospatial data sources\nZonal statistics and demographic analysis\nInteractive web mapping\nReproducible research workflows"
  },
  {
    "objectID": "about.html#project-context",
    "href": "about.html#project-context",
    "title": "About",
    "section": "",
    "text": "This analysis was developed as the final project for MUSA 5500: Geospatial Data Science in Python at the University of Pennsylvania Weitzman School of Design.\nThe project demonstrates proficiency in:\n\nRaster analysis and terrain processing\nIntegration of multiple geospatial data sources\nZonal statistics and demographic analysis\nInteractive web mapping\nReproducible research workflows"
  },
  {
    "objectID": "about.html#why-honolulu",
    "href": "about.html#why-honolulu",
    "title": "About",
    "section": "Why Honolulu?",
    "text": "Why Honolulu?\nHonolulu County presents a compelling case study for flood risk analysis:\n\nPersonal connection: I grew up on Oahu and have seen firsthand how flooding affects island communities\nIsland geography creates a bounded study area with clear coastal exposure\nDiverse terrain from sea level to 1,200m+ within a compact area\nDense population concentrated in low-lying coastal zones\nReal policy relevance given climate change and sea level rise projections\nHigh-quality data availability from USGS and Census"
  },
  {
    "objectID": "about.html#data-sources",
    "href": "about.html#data-sources",
    "title": "About",
    "section": "Data Sources",
    "text": "Data Sources\n\n\n\nDataset\nSource\nAccess\n\n\n\n\nDigital Elevation Model\nUSGS 3DEP\nNational Map\n\n\nHydrography\nUSGS NHD\nNational Map\n\n\nCensus Boundaries\nCensus TIGER/Line\nCensus Bureau\n\n\nPopulation Data\nACS 2020 5-Year\nCensus API"
  },
  {
    "objectID": "about.html#limitations-future-work",
    "href": "about.html#limitations-future-work",
    "title": "About",
    "section": "Limitations & Future Work",
    "text": "Limitations & Future Work\n\nCurrent Limitations\n\nStatic risk model: Does not incorporate probabilistic flood modeling or climate projections\nPopulation distribution: Assumes uniform distribution within block groups\nSingle hazard focus: Does not address other hazards (tsunami, wildfire, etc.)\n\n\n\nPotential Extensions\n\nIncorporate NOAA sea level rise projections\nAdd FEMA flood zone data as validation layer\nModel population change scenarios\nConduct evacuation route analysis\nCompare with insurance claims or historical flood records"
  },
  {
    "objectID": "about.html#author",
    "href": "about.html#author",
    "title": "About",
    "section": "Author",
    "text": "Author\nOliver Iyer\nMaster of Public Administration in Quantitative Policy Analysis Candidate\nUniversity of Pennsylvania, Fels Institute of Government\n\nLinkedIn"
  },
  {
    "objectID": "about.html#acknowledgments",
    "href": "about.html#acknowledgments",
    "title": "About",
    "section": "Acknowledgments",
    "text": "Acknowledgments\n\nInstructor: Xiaojiang Li\nData Providers: USGS, US Census Bureau\nTools: Python open-source geospatial community\n\n\nDecember 2025"
  },
  {
    "objectID": "methodology.html",
    "href": "methodology.html",
    "title": "Methodology",
    "section": "",
    "text": "This analysis follows a four-stage workflow: data acquisition, preprocessing, risk modeling, and population exposure calculation. The approach combines raster-based terrain analysis with vector-based demographic data to produce a composite flood risk assessment."
  },
  {
    "objectID": "methodology.html#overview",
    "href": "methodology.html#overview",
    "title": "Methodology",
    "section": "",
    "text": "This analysis follows a four-stage workflow: data acquisition, preprocessing, risk modeling, and population exposure calculation. The approach combines raster-based terrain analysis with vector-based demographic data to produce a composite flood risk assessment."
  },
  {
    "objectID": "methodology.html#data-sources",
    "href": "methodology.html#data-sources",
    "title": "Methodology",
    "section": "Data Sources",
    "text": "Data Sources\n\nElevation Data\nUSGS 3D Elevation Program (3DEP)\n\nSource: USGS National Map\nProduct: Digital Elevation Model (DEM) for Oahu\nNative resolution: ~1m\nWorking resolution: 10m (resampled for computational efficiency)\nCoordinate system: UTM Zone 4N (EPSG:26904)\n\n\n\nHydrological Features\nUSGS National Hydrography Dataset (NHD)\n\nStreams and rivers: 2,340 linear features\nCoastline: 4 polygon features\nUsed for: Proximity-based risk calculation (streams only)\n\n\n\n\n\n\n\nNoteDesign Decision: Inland Waterways Only\n\n\n\nThe proximity component uses only inland streams and rivers, not the coastline. Including the coastline would make the entire island appear high-risk (everything is near the ocean), eliminating meaningful spatial differentiation. Coastal flooding is captured through the elevation component instead.\n\n\n\n\n\nProximity Analysis - Inland Waterways Only\n\n\n\n\nDemographic Data\nUS Census Bureau\n\nGeography: TIGER/Line shapefiles (census block groups)\nPopulation: American Community Survey 2020 5-year estimates\nVariable: B01003_001E (total population)\nBlock groups analyzed: 703"
  },
  {
    "objectID": "methodology.html#flood-risk-model",
    "href": "methodology.html#flood-risk-model",
    "title": "Methodology",
    "section": "Flood Risk Model",
    "text": "Flood Risk Model\n\nConceptual Framework\nFlood risk is modeled as a weighted combination of two factors:\n\n\n\n\n\n\n\n\nFactor\nWeight\nRationale\n\n\n\n\nElevation\n70%\nPrimary driver of coastal and pluvial flood risk\n\n\nProximity to Waterways\n30%\nCaptures riverine flood risk near streams\n\n\n\nThe heavier elevation weighting reflects Oahu‚Äôs island geography, where coastal flooding and sea level rise represent the dominant long-term risk.\n\n\nElevation Risk Classification\n\n\n\nCategory\nElevation\nRisk Score\n\n\n\n\nHigh\n&lt; 3m\n3\n\n\nModerate\n3 - 8m\n2\n\n\nLow\n&gt; 8m\n1\n\n\n\nThresholds are based on:\n\n3m: Approximate reach of storm surge in major hurricanes\n8m: Upper limit of compound flooding (surge + rainfall)\n\n\n\nProximity Risk Classification\n\n\n\nCategory\nDistance to Stream\nRisk Score\n\n\n\n\nHigh\n&lt; 100m\n3\n\n\nModerate\n100 - 500m\n2\n\n\nLow\n&gt; 500m\n1\n\n\n\nDistances are calculated using Euclidean distance transform from rasterized waterway features.\n\n\nComposite Risk Calculation\n\\[\nRisk_{composite} = 0.70 \\times Risk_{elevation} + 0.30 \\times Risk_{proximity}\n\\]\nThe continuous composite score (range 1.0 - 3.0) is then classified:\n\n\n\nFinal Category\nComposite Score\n\n\n\n\nLow\n&lt; 1.5\n\n\nModerate\n1.5 - 2.3\n\n\nHigh\n&gt; 2.3\n\n\n\n\n\n\nFlood Risk Model Components"
  },
  {
    "objectID": "methodology.html#population-exposure-analysis",
    "href": "methodology.html#population-exposure-analysis",
    "title": "Methodology",
    "section": "Population Exposure Analysis",
    "text": "Population Exposure Analysis\n\nZonal Statistics\nPopulation exposure is calculated using zonal statistics:\n\nOverlay census block group polygons on the classified risk raster\nCount pixels in each risk category per block group\nCalculate percentage of area in each risk category\nAllocate population proportionally based on area percentages\n\n\\[\nPop_{high-risk} = Pop_{total} \\times \\frac{Area_{high-risk}}{Area_{total}}\n\\]\n\n\nAssumptions\n\n\n\n\n\n\nWarningUniform Population Distribution\n\n\n\nThis method assumes population is evenly distributed within each block group. In reality, population clusters in developed areas, which may systematically differ in risk level from undeveloped portions of the same block group."
  },
  {
    "objectID": "methodology.html#software-tools",
    "href": "methodology.html#software-tools",
    "title": "Methodology",
    "section": "Software & Tools",
    "text": "Software & Tools\n\n\n\nTool\nPurpose\n\n\n\n\nPython 3.11\nPrimary analysis environment\n\n\nGeoPandas\nVector data processing\n\n\nRasterio\nRaster data I/O\n\n\nRasterstats\nZonal statistics\n\n\nSciPy\nDistance transform calculations\n\n\nFolium\nInteractive web mapping\n\n\nMatplotlib\nStatic visualizations\n\n\nQuarto\nWebsite generation"
  },
  {
    "objectID": "methodology.html#code-repository",
    "href": "methodology.html#code-repository",
    "title": "Methodology",
    "section": "Code Repository",
    "text": "Code Repository\nAnalysis notebooks are available in the project repository:\n\n01_data_preprocessing.ipynb - Data acquisition and cleaning\n02_flood_risk_modeling.ipynb - Risk model implementation\n03_population_exposure.ipynb - Demographic analysis\n04_visualization.ipynb - Map and figure generation"
  },
  {
    "objectID": "script/01_data_preprocessing.html",
    "href": "script/01_data_preprocessing.html",
    "title": "High Tide Ahead",
    "section": "",
    "text": "# Data manipulation and analysis\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nfrom shapely.geometry import Point, Polygon, box\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Raster processing\nimport rasterio\nfrom rasterio.mask import mask\nfrom rasterio.warp import calculate_default_transform, reproject\nfrom rasterio.enums import Resampling\nfrom rasterio.features import rasterize\n\n# Visualization\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# System\nimport os\nfrom pathlib import Path\n\n# Set style\nsns.set_style(\"whitegrid\")\nplt.rcParams['figure.figsize'] = (12, 8)\n\nprint(\"‚úì All libraries imported successfully\")\n\n‚úì All libraries imported successfully\n\n\n\n# Create directory structure\ndirectories = [\n    'data/raw',\n    'data/processed',\n    'outputs/maps',\n    'outputs/figures',\n    'outputs/data'\n]\n\nfor directory in directories:\n    Path(directory).mkdir(parents=True, exist_ok=True)\n    \nprint(\"‚úì Directory structure created\")\n\n‚úì Directory structure created\n\n\n\n# Define file paths - UPDATED WITH YOUR ACTUAL FILENAMES\nRAW_DATA = {\n    'waterways': 'data/raw/Streams.shp',\n    'lines': 'data/raw/Coastline.shp',\n    'census_bg': 'data/raw/tl_2020_15_bg.shp',\n    'counties': 'data/raw/tl_2024_us_county.shp',\n    'dem': 'data/raw/Oahu_DSM.tif'  # Update if different\n}\n\n# Target CRS for Honolulu (NAD83 / Hawaii zone 3)\nTARGET_CRS = 'EPSG:3759'\n\n# Honolulu County FIPS code\nHONOLULU_FIPS = '15003'\n\nprint(\"‚úì File paths configured\")\nprint(f\"‚úì Target CRS: {TARGET_CRS}\")\n\n‚úì File paths configured\n‚úì Target CRS: EPSG:3759\n\n\n\n# Load county boundaries\nprint(\"Loading county boundaries...\")\ncounties = gpd.read_file(RAW_DATA['counties'])\n\n# Filter for Honolulu County\nhonolulu = counties[counties['GEOID'] == HONOLULU_FIPS].copy()\n\nif len(honolulu) == 0:\n    print(\"‚ö†Ô∏è Warning: No Honolulu County found. Available GEOID values:\")\n    print(counties[counties['STATEFP'] == '15']['GEOID'].values)\nelse:\n    print(f\"‚úì Honolulu County loaded: {honolulu['NAME'].values[0]}\")\n    print(f\"  Original CRS: {honolulu.crs}\")\n    print(f\"  Geometry type: {honolulu.geometry.type.values[0]}\")\n\n# Reproject to target CRS\nhonolulu = honolulu.to_crs(TARGET_CRS)\nprint(f\"‚úì Reprojected to {TARGET_CRS}\")\n\n# Save processed boundary\nhonolulu.to_file('data/processed/honolulu_boundary.shp')\nprint(\"‚úì Saved: data/processed/honolulu_boundary.shp\")\n\nLoading county boundaries...\n‚úì Honolulu County loaded: Honolulu\n  Original CRS: EPSG:4269\n  Geometry type: MultiPolygon\n‚úì Reprojected to EPSG:3759\n‚úì Saved: data/processed/honolulu_boundary.shp\n\n\n\n# Visualize Honolulu County boundary\nfig, ax = plt.subplots(1, 1, figsize=(10, 8))\nhonolulu.plot(ax=ax, facecolor='lightblue', edgecolor='navy', linewidth=2)\nax.set_title('Study Area: Honolulu County, Hawaii', fontsize=16, fontweight='bold')\nax.set_xlabel('Easting (m)', fontsize=12)\nax.set_ylabel('Northing (m)', fontsize=12)\nplt.tight_layout()\nplt.savefig('outputs/figures/01_study_area.png', dpi=300, bbox_inches='tight')\nplt.show()\n\nprint(f\"‚úì Study area bounds: {honolulu.total_bounds}\")\n\n\n\n\n\n\n\n\n‚úì Study area bounds: [-5007795.82807378    11870.19523467  1777498.79143474  3246934.66955564]\n\n\n\n# Load waterways\nprint(\"Loading waterways...\")\nwaterways = gpd.read_file(RAW_DATA['waterways'])\nprint(f\"  Loaded {len(waterways)} waterway features\")\nprint(f\"  Original CRS: {waterways.crs}\")\n\n# Reproject and clip to Honolulu\nwaterways = waterways.to_crs(TARGET_CRS)\nwaterways_honolulu = gpd.clip(waterways, honolulu)\nprint(f\"‚úì Clipped to Honolulu: {len(waterways_honolulu)} features remaining\")\n\n# Save processed waterways\nwaterways_honolulu.to_file('data/processed/waterways_honolulu.shp')\nprint(\"‚úì Saved: data/processed/waterways_honolulu.shp\")\n\nLoading waterways...\n  Loaded 10785 waterway features\n  Original CRS: EPSG:3750\n‚úì Clipped to Honolulu: 2340 features remaining\n‚úì Saved: data/processed/waterways_honolulu.shp\n\n\n\n# Load lines (assuming these are coastlines or additional water features)\nprint(\"Loading lines...\")\nlines = gpd.read_file(RAW_DATA['lines'])\nprint(f\"  Loaded {len(lines)} line features\")\nprint(f\"  Original CRS: {lines.crs}\")\n\n# Reproject and clip to Honolulu\nlines = lines.to_crs(TARGET_CRS)\nlines_honolulu = gpd.clip(lines, honolulu)\nprint(f\"‚úì Clipped to Honolulu: {len(lines_honolulu)} features remaining\")\n\n# Save processed lines\nlines_honolulu.to_file('data/processed/lines_honolulu.shp')\nprint(\"‚úì Saved: data/processed/lines_honolulu.shp\")\n\nLoading lines...\n  Loaded 13 line features\n  Original CRS: EPSG:3750\n‚úì Clipped to Honolulu: 4 features remaining\n‚úì Saved: data/processed/lines_honolulu.shp\n\n\n\n# Load census block groups\nprint(\"Loading census block groups...\")\ncensus_bg = gpd.read_file(RAW_DATA['census_bg'])\nprint(f\"  Loaded {len(census_bg)} block groups\")\nprint(f\"  Original CRS: {census_bg.crs}\")\n\n# Filter for Honolulu County (COUNTYFP == '003')\ncensus_bg_honolulu = census_bg[census_bg['COUNTYFP'] == '003'].copy()\nprint(f\"‚úì Filtered to Honolulu: {len(census_bg_honolulu)} block groups\")\n\n# Reproject to target CRS\ncensus_bg_honolulu = census_bg_honolulu.to_crs(TARGET_CRS)\nprint(f\"‚úì Reprojected to {TARGET_CRS}\")\n\n# Display available columns\nprint(\"\\nAvailable census columns:\")\nprint(census_bg_honolulu.columns.tolist())\n\n# Save processed census data\ncensus_bg_honolulu.to_file('data/processed/census_bg_honolulu.shp')\nprint(\"‚úì Saved: data/processed/census_bg_honolulu.shp\")\n\nLoading census block groups...\n  Loaded 1083 block groups\n  Original CRS: EPSG:4269\n‚úì Filtered to Honolulu: 774 block groups\n‚úì Reprojected to EPSG:3759\n\nAvailable census columns:\n['STATEFP', 'COUNTYFP', 'TRACTCE', 'BLKGRPCE', 'GEOID', 'NAMELSAD', 'MTFCC', 'FUNCSTAT', 'ALAND', 'AWATER', 'INTPTLAT', 'INTPTLON', 'geometry']\n‚úì Saved: data/processed/census_bg_honolulu.shp\n\n\n\nprint(\"IMPORTANT: You need to add population data\")\nprint(\"Options:\")\nprint(\"1. Download ACS 2020 5-year estimates from data.census.gov\")\nprint(\"2. Use tidycensus in R or censusdata in Python\")\nprint(\"3. Manually join population data to census_bg_honolulu\")\n\n\n)\nnp.random.seed(42)\ncensus_bg_honolulu['total_population'] = np.random.randint(500, 5000, len(census_bg_honolulu))\nprint(\"‚ö†Ô∏è Using synthetic population data for demonstration\")\nprint(f\"‚úì Total population (synthetic): {census_bg_honolulu['total_population'].sum():,}\")\n\n‚ö†Ô∏è IMPORTANT: You need to add population data\nOptions:\n1. Download ACS 2020 5-year estimates from data.census.gov\n2. Use tidycensus in R or censusdata in Python\n3. Manually join population data to census_bg_honolulu\n‚ö†Ô∏è Using synthetic population data for demonstration\n‚úì Total population (synthetic): 2,163,336\n\n\n\n# Load and process DEM\nprint(\"Loading DEM...\")\nwith rasterio.open(RAW_DATA['dem']) as src:\n    print(f\"  DEM CRS: {src.crs}\")\n    print(f\"  DEM shape: {src.shape}\")\n    print(f\"  DEM resolution: {src.res}\")\n    print(f\"  DEM bounds: {src.bounds}\")\n    \n    # Reproject Honolulu boundary to DEM CRS for clipping\n    honolulu_dem_crs = honolulu.to_crs(src.crs)\n    \n    # Clip DEM to Honolulu boundary\n    geom = [honolulu_dem_crs.geometry.values[0]]\n    out_image, out_transform = mask(src, geom, crop=True, nodata=-9999)\n    out_meta = src.meta.copy()\n    \n    out_meta.update({\n        \"driver\": \"GTiff\",\n        \"height\": out_image.shape[1],\n        \"width\": out_image.shape[2],\n        \"transform\": out_transform,\n        \"nodata\": -9999\n    })\n\n# Save clipped DEM in original CRS\nclipped_dem_path = 'data/processed/dem_honolulu_original_crs.tif'\nwith rasterio.open(clipped_dem_path, 'w', **out_meta) as dest:\n    dest.write(out_image)\n\nprint(f\"‚úì Clipped DEM saved: {clipped_dem_path}\")\n\nLoading DEM...\n  DEM CRS: EPSG:3750\n  DEM shape: (52328, 67407)\n  DEM resolution: (1.0, 1.0)\n  DEM bounds: BoundingBox(left=573085.9947693374, bottom=2350512.550161029, right=640492.9947693374, top=2402840.550161029)\n‚úì Clipped DEM saved: data/processed/dem_honolulu_original_crs.tif\n\n\n\n# Reproject DEM to target CRS (EPSG:3759)\nprint(f\"Reprojecting DEM to {TARGET_CRS}...\")\n\nwith rasterio.open(clipped_dem_path) as src:\n    # Calculate optimal transform and dimensions\n    transform, width, height = calculate_default_transform(\n        src.crs, TARGET_CRS, src.width, src.height, *src.bounds\n    )\n    \n    kwargs = src.meta.copy()\n    kwargs.update({\n        'crs': TARGET_CRS,\n        'transform': transform,\n        'width': width,\n        'height': height\n    })\n    \n    # Reproject and save\n    reprojected_dem_path = 'data/processed/dem_honolulu.tif'\n    with rasterio.open(reprojected_dem_path, 'w', **kwargs) as dst:\n        for i in range(1, src.count + 1):\n            reproject(\n                source=rasterio.band(src, i),\n                destination=rasterio.band(dst, i),\n                src_transform=src.transform,\n                src_crs=src.crs,\n                dst_transform=transform,\n                dst_crs=TARGET_CRS,\n                resampling=Resampling.bilinear\n            )\n\nprint(f\"‚úì Reprojected DEM saved: {reprojected_dem_path}\")\n\n# Verify reprojected DEM\nwith rasterio.open(reprojected_dem_path) as src:\n    print(f\"  Final CRS: {src.crs}\")\n    print(f\"  Final shape: {src.shape}\")\n    print(f\"  Final resolution: {src.res}\")\n\nReprojecting DEM to EPSG:3759...\n‚úì Reprojected DEM saved: data/processed/dem_honolulu.tif\n  Final CRS: EPSG:3759\n  Final shape: (52758, 67740)\n  Final resolution: (3.281650196067137, 3.281650196067137)\n\n\n\n# Create comprehensive visualization\nfig, ax = plt.subplots(1, 1, figsize=(14, 10))\n\n# Plot DEM\nwith rasterio.open(reprojected_dem_path) as src:\n    dem_data = src.read(1)\n    dem_data = np.where(dem_data == -9999, np.nan, dem_data)\n    \n    from rasterio.plot import show\n    show(dem_data, transform=src.transform, ax=ax, cmap='terrain', \n         vmin=0, vmax=np.nanpercentile(dem_data, 99))\n\n# Overlay vector data\nwaterways_honolulu.plot(ax=ax, color='blue', linewidth=1, alpha=0.6, label='Waterways')\nlines_honolulu.plot(ax=ax, color='darkblue', linewidth=2, alpha=0.8, label='Coastline/Lines')\ncensus_bg_honolulu.boundary.plot(ax=ax, color='red', linewidth=0.5, alpha=0.5, label='Census Block Groups')\nhonolulu.boundary.plot(ax=ax, color='black', linewidth=3, label='County Boundary')\n\nax.set_title('Honolulu County: Processed Spatial Data', fontsize=16, fontweight='bold')\nax.set_xlabel('Easting (m)', fontsize=12)\nax.set_ylabel('Northing (m)', fontsize=12)\nax.legend(loc='upper right')\n\nplt.tight_layout()\nplt.savefig('outputs/figures/02_all_processed_data.png', dpi=300, bbox_inches='tight')\nplt.show()\n\nprint(\"‚úì Data preprocessing complete!\")\n\n\n---------------------------------------------------------------------------\nMemoryError                               Traceback (most recent call last)\nCell In[12], line 11\n      7     dem_data = np.where(dem_data == -9999, np.nan, dem_data)\n      9     from rasterio.plot import show\n     10     show(dem_data, transform=src.transform, ax=ax, cmap='terrain', \n---&gt; 11          vmin=0, vmax=np.nanpercentile(dem_data, 99))\n     13 # Overlay vector data\n     14 waterways_honolulu.plot(ax=ax, color='blue', linewidth=1, alpha=0.6, label='Waterways')\n\nFile ~\\anaconda3\\envs\\geospatial\\Lib\\site-packages\\numpy\\lib\\_nanfunctions_impl.py:1406, in nanpercentile(a, q, axis, out, overwrite_input, method, keepdims, weights, interpolation)\n   1403     if np.any(weights &lt; 0):\n   1404         raise ValueError(\"Weights must be non-negative.\")\n-&gt; 1406 return _nanquantile_unchecked(\n   1407     a, q, axis, out, overwrite_input, method, keepdims, weights)\n\nFile ~\\anaconda3\\envs\\geospatial\\Lib\\site-packages\\numpy\\lib\\_nanfunctions_impl.py:1617, in _nanquantile_unchecked(a, q, axis, out, overwrite_input, method, keepdims, weights)\n   1615 if a.size == 0:\n   1616     return np.nanmean(a, axis, out=out, keepdims=keepdims)\n-&gt; 1617 return fnb._ureduce(a,\n   1618                     func=_nanquantile_ureduce_func,\n   1619                     q=q,\n   1620                     weights=weights,\n   1621                     keepdims=keepdims,\n   1622                     axis=axis,\n   1623                     out=out,\n   1624                     overwrite_input=overwrite_input,\n   1625                     method=method)\n\nFile ~\\anaconda3\\envs\\geospatial\\Lib\\site-packages\\numpy\\lib\\_function_base_impl.py:3914, in _ureduce(a, func, keepdims, **kwargs)\n   3911     index_out = (0, ) * nd\n   3912     kwargs['out'] = out[(Ellipsis, ) + index_out]\n-&gt; 3914 r = func(a, **kwargs)\n   3916 if out is not None:\n   3917     return out\n\nFile ~\\anaconda3\\envs\\geospatial\\Lib\\site-packages\\numpy\\lib\\_nanfunctions_impl.py:1645, in _nanquantile_ureduce_func(a, q, weights, axis, out, overwrite_input, method)\n   1643     part = a.ravel()\n   1644     wgt = None if weights is None else weights.ravel()\n-&gt; 1645     result = _nanquantile_1d(part, q, overwrite_input, method, weights=wgt)\n   1646 # Note that this code could try to fill in `out` right away\n   1647 elif weights is None:\n\nFile ~\\anaconda3\\envs\\geospatial\\Lib\\site-packages\\numpy\\lib\\_nanfunctions_impl.py:1690, in _nanquantile_1d(arr1d, q, overwrite_input, method, weights)\n   1685 \"\"\"\n   1686 Private function for rank 1 arrays. Compute quantile ignoring NaNs.\n   1687 See nanpercentile for parameter usage\n   1688 \"\"\"\n   1689 # TODO: What to do when arr1d = [1, np.nan] and weights = [0, 1]?\n-&gt; 1690 arr1d, weights, overwrite_input = _remove_nan_1d(arr1d,\n   1691     second_arr1d=weights, overwrite_input=overwrite_input)\n   1692 if arr1d.size == 0:\n   1693     # convert to scalar\n   1694     return np.full(q.shape, np.nan, dtype=arr1d.dtype)[()]\n\nFile ~\\anaconda3\\envs\\geospatial\\Lib\\site-packages\\numpy\\lib\\_nanfunctions_impl.py:187, in _remove_nan_1d(arr1d, second_arr1d, overwrite_input)\n    185 else:\n    186     if not overwrite_input:\n--&gt; 187         arr1d = arr1d.copy()\n    188     # select non-nans at end of array\n    189     enonan = arr1d[-s.size:][~c[-s.size:]]\n\nMemoryError: Unable to allocate 13.3 GiB for an array with shape (3573826920,) and data type float32\n\n\n\n\n\n\n\n\n\n\n\n# Generate summary statistics\nprint(\"=\"*60)\nprint(\"DATA PREPROCESSING SUMMARY\")\nprint(\"=\"*60)\n\nprint(f\"\\nüìç Study Area: Honolulu County\")\nprint(f\"   CRS: {TARGET_CRS}\")\nprint(f\"   Area: {honolulu.geometry.area.values[0]/1e6:.2f} km¬≤\")\n\nprint(f\"\\n Waterways:\")\nprint(f\"   Features: {len(waterways_honolulu)}\")\nprint(f\"   Total length: {waterways_honolulu.length.sum()/1000:.2f} km\")\n\nprint(f\"\\n Lines/Coastline:\")\nprint(f\"   Features: {len(lines_honolulu)}\")\nprint(f\"   Total length: {lines_honolulu.length.sum()/1000:.2f} km\")\n\nprint(f\"\\n Census Block Groups:\")\nprint(f\"   Count: {len(census_bg_honolulu)}\")\nprint(f\"   Total population: {census_bg_honolulu['total_population'].sum():,}\")\nprint(f\"   Avg population per BG: {census_bg_honolulu['total_population'].mean():.0f}\")\n\nwith rasterio.open(reprojected_dem_path) as src:\n    dem_data = src.read(1)\n    dem_data = dem_data[dem_data != -9999]\n    \n    print(f\"\\n Digital Elevation Model:\")\n    print(f\"   Resolution: {src.res[0]:.1f}m √ó {src.res[1]:.1f}m\")\n    print(f\"   Dimensions: {src.shape[0]} √ó {src.shape[1]} pixels\")\n    print(f\"   Elevation range: {dem_data.min():.1f}m to {dem_data.max():.1f}m\")\n    print(f\"   Mean elevation: {dem_data.mean():.1f}m\")\n\nprint(\"\\n‚úì All data successfully preprocessed and ready for analysis\")\nprint(\"=\"*60)\n\n============================================================\nDATA PREPROCESSING SUMMARY\n============================================================\n\nüìç Study Area: Honolulu County\n   CRS: EPSG:3759\n   Area: 61973.65 km¬≤\n\nüåä Waterways:\n   Features: 2340\n   Total length: 7849.08 km\n\nüèñÔ∏è Lines/Coastline:\n   Features: 4\n   Total length: 1316.63 km\n\nüèòÔ∏è Census Block Groups:\n   Count: 774\n   Total population: 2,163,336\n   Avg population per BG: 2795\n\n\n\n---------------------------------------------------------------------------\nMemoryError                               Traceback (most recent call last)\nCell In[13], line 24\n     21 print(f\"   Avg population per BG: {census_bg_honolulu['total_population'].mean():.0f}\")\n     23 with rasterio.open(reprojected_dem_path) as src:\n---&gt; 24     dem_data = src.read(1)\n     25     dem_data = dem_data[dem_data != -9999]\n     27     print(f\"\\n‚õ∞Ô∏è Digital Elevation Model:\")\n\nFile rasterio\\\\_io.pyx:620, in rasterio._io.DatasetReaderBase.read()\n\nMemoryError: Unable to allocate 13.3 GiB for an array with shape (1, 52758, 67740) and data type float32"
  },
  {
    "objectID": "script/03_population_exposure.html",
    "href": "script/03_population_exposure.html",
    "title": "High Tide Ahead",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport rasterio\nfrom rasterstats import zonal_stats\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom pathlib import Path\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Set style\nsns.set_style(\"whitegrid\")\nplt.rcParams['figure.figsize'] = (12, 8)\n\nprint(\"Loading data...\")\n\n# Load census block groups\ncensus_bg = gpd.read_file('data/processed/census_bg_honolulu.shp')\nprint(f\"‚úì Loaded {len(census_bg)} census block groups\")\n\n# Load boundary for reference\nhonolulu = gpd.read_file('data/processed/honolulu_boundary.shp')\n\n# Check for population data\npop_col = None\nfor col in ['total_population', 'total_popu', 'POPULATION', 'POP']:\n    if col in census_bg.columns:\n        pop_col = col\n        break\n\nif pop_col:\n    if pop_col != 'total_population':\n        census_bg['total_population'] = census_bg[pop_col]\n    print(f\"‚úì Population data found: {census_bg['total_population'].sum():,.0f} total\")\nelse:\n    print(\"‚ö†Ô∏è No population data found - will download from Census API\")\n\n# Load risk raster path\nrisk_raster_path = 'data/processed/final_flood_risk.tif'\n\nwith rasterio.open(risk_raster_path) as src:\n    print(f\"\\n‚úì Risk raster: {src.shape[0]} √ó {src.shape[1]} pixels\")\n    print(f\"  Resolution: {src.res[0]:.1f}m\")\n\nLoading data...\n‚úì Loaded 774 census block groups\n‚úì Population data found: 979,682 total\n\n‚úì Risk raster: 17313 √ó 22229 pixels\n  Resolution: 10.0m\n\n\n\n\nif 'total_population' not in census_bg.columns or census_bg['total_population'].isna().all():\n    print(\"\\n\" + \"=\" * 70)\n    print(\"DOWNLOADING POPULATION DATA FROM CENSUS API\")\n    print(\"=\" * 70)\n    \n    try:\n        import censusdata\n    except ImportError:\n        print(\"Installing censusdata package...\")\n        import subprocess\n        import sys\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"censusdata\"])\n        import censusdata\n    \n    print(\"\\nDownloading ACS 2020 5-year estimates...\")\n    print(\"(This may take 30-60 seconds...)\")\n    \n    try:\n        pop_data = censusdata.download(\n            'acs5', 2020,\n            censusdata.censusgeo([\n                ('state', '15'),\n                ('county', '003'),\n                ('block group', '*')\n            ]),\n            ['B01003_001E']\n        )\n        \n        print(f\"‚úì Downloaded data for {len(pop_data)} block groups\")\n        pop_data = pop_data.reset_index()\n        \n        def extract_geoid(censusgeo_obj):\n            try:\n                parts = censusgeo_obj.geo\n                return f\"{parts[0][1]}{parts[1][1]}{parts[2][1]}{parts[3][1]}\"\n            except:\n                return None\n        \n        pop_data['GEOID'] = pop_data['index'].apply(extract_geoid)\n        pop_data = pop_data[pop_data['GEOID'].notna()]\n        pop_data.rename(columns={'B01003_001E': 'total_population'}, inplace=True)\n        \n        census_geoid_len = len(str(census_bg['GEOID'].iloc[0]))\n        pop_data['GEOID'] = pop_data['GEOID'].str.zfill(census_geoid_len)\n        \n        census_bg = census_bg.merge(pop_data[['GEOID', 'total_population']], on='GEOID', how='left', suffixes=('_old', ''))\n        \n        if 'total_population_old' in census_bg.columns:\n            census_bg['total_population'] = census_bg['total_population'].fillna(census_bg['total_population_old'])\n            census_bg.drop(columns=['total_population_old'], inplace=True)\n        \n        census_bg['total_population'] = census_bg['total_population'].fillna(0).astype(int)\n        \n        print(f\"\\n‚úì Total population: {census_bg['total_population'].sum():,.0f}\")\n        census_bg.to_file('data/processed/census_bg_honolulu.shp')\n        print(\"‚úì Saved updated census data\")\n        \n    except Exception as e:\n        print(f\"\\n‚ùå Error: {e}\")\n        print(\"Using placeholder values...\")\n        np.random.seed(42)\n        census_bg['total_population'] = np.random.randint(500, 3000, len(census_bg))\nelse:\n    print(f\"\\n‚úì Population data already present: {census_bg['total_population'].sum():,.0f} total\")\n\n\n‚úì Population data already present: 979,682 total\n\n\n\n\nprint(\"Filtering to Oahu island only...\")\n\ncensus_bg['centroid_x'] = census_bg.geometry.centroid.x\ncensus_bg['centroid_y'] = census_bg.geometry.centroid.y\n\nx_median = census_bg['centroid_x'].median()\nx_std = census_bg['centroid_x'].std()\ny_median = census_bg['centroid_y'].median()\ny_std = census_bg['centroid_y'].std()\n\ncensus_bg_oahu = census_bg[\n    (census_bg['centroid_x'] &gt; (x_median - 2*x_std)) &\n    (census_bg['centroid_x'] &lt; (x_median + 2*x_std)) &\n    (census_bg['centroid_y'] &gt; (y_median - 2*y_std)) &\n    (census_bg['centroid_y'] &lt; (y_median + 2*y_std))\n].copy()\n\nprint(f\"  Original: {len(census_bg)} block groups\")\nprint(f\"  Oahu only: {len(census_bg_oahu)} block groups\")\nprint(f\"  Removed: {len(census_bg) - len(census_bg_oahu)} distant island block groups\")\n\ncensus_bg = census_bg_oahu.drop(columns=['centroid_x', 'centroid_y'])\n\nprint(f\"\\n‚úì Working with {len(census_bg)} block groups\")\nprint(f\"  Total population: {census_bg['total_population'].sum():,.0f}\")\n\nFiltering to Oahu island only...\n  Original: 774 block groups\n  Oahu only: 773 block groups\n  Removed: 1 distant island block groups\n\n‚úì Working with 773 block groups\n  Total population: 979,682\n\n\n\n\nprint(\"Calculating zonal statistics...\")\nprint(\"(This may take 1-2 minutes...)\")\n\nstats = zonal_stats(\n    census_bg,\n    risk_raster_path,\n    stats=['count', 'mean'],\n    categorical=True,\n    nodata=0,\n    geojson_out=False\n)\n\nstats_df = pd.DataFrame(stats)\nprint(f\"\\n‚úì Zonal statistics complete\")\nprint(f\"  Columns returned: {list(stats_df.columns)}\")\n\ndef get_risk_column(df, value):\n    for col in [value, float(value), str(value), f'{value}.0']:\n        if col in df.columns:\n            return col\n    return None\n\nlow_col = get_risk_column(stats_df, 1)\nmod_col = get_risk_column(stats_df, 2)\nhigh_col = get_risk_column(stats_df, 3)\n\nprint(f\"\\n  Risk column mapping:\")\nprint(f\"    Low (1): {low_col}\")\nprint(f\"    Moderate (2): {mod_col}\")\nprint(f\"    High (3): {high_col}\")\n\nif low_col and mod_col and high_col:\n    census_bg['pixels_low'] = stats_df[low_col].fillna(0)\n    census_bg['pixels_moderate'] = stats_df[mod_col].fillna(0)\n    census_bg['pixels_high'] = stats_df[high_col].fillna(0)\n    print(\"\\n‚úì Using categorical pixel counts\")\nelse:\n    print(\"\\n‚ö†Ô∏è Categorical columns not found, estimating from mean...\")\n    census_bg['risk_mean'] = stats_df['mean'].fillna(0)\n    census_bg['risk_count'] = stats_df['count'].fillna(0)\n    \n    def estimate_pixels(row):\n        total = row['risk_count']\n        mean = row['risk_mean']\n        if total == 0 or pd.isna(mean):\n            return 0, 0, 0\n        if mean &lt; 1.5:\n            return total * 0.7, total * 0.2, total * 0.1\n        elif mean &lt; 2.5:\n            return total * 0.2, total * 0.6, total * 0.2\n        else:\n            return total * 0.1, total * 0.2, total * 0.7\n    \n    estimates = census_bg.apply(estimate_pixels, axis=1, result_type='expand')\n    census_bg['pixels_low'] = estimates[0]\n    census_bg['pixels_moderate'] = estimates[1]\n    census_bg['pixels_high'] = estimates[2]\n\ncensus_bg['pixels_total'] = census_bg['pixels_low'] + census_bg['pixels_moderate'] + census_bg['pixels_high']\n\nCalculating zonal statistics...\n(This may take 1-2 minutes...)\n\n‚úì Zonal statistics complete\n  Columns returned: [1, 'mean', 'count', 2, 3]\n\n  Risk column mapping:\n    Low (1): 1\n    Moderate (2): 2\n    High (3): 3\n\n‚úì Using categorical pixel counts\n\n\n\n\nprint(\"Calculating population exposure metrics...\")\n\ncensus_bg['pct_low'] = (census_bg['pixels_low'] / census_bg['pixels_total'] * 100).fillna(0)\ncensus_bg['pct_moderate'] = (census_bg['pixels_moderate'] / census_bg['pixels_total'] * 100).fillna(0)\ncensus_bg['pct_high'] = (census_bg['pixels_high'] / census_bg['pixels_total'] * 100).fillna(0)\n\ncensus_bg['pop_low_risk'] = (census_bg['pct_low'] / 100 * census_bg['total_population']).round()\ncensus_bg['pop_moderate_risk'] = (census_bg['pct_moderate'] / 100 * census_bg['total_population']).round()\ncensus_bg['pop_high_risk'] = (census_bg['pct_high'] / 100 * census_bg['total_population']).round()\n\ndef get_dominant_risk(row):\n    if row['pixels_total'] == 0:\n        return 'No Data'\n    max_pixels = max(row['pixels_low'], row['pixels_moderate'], row['pixels_high'])\n    if max_pixels == row['pixels_high']:\n        return 'High'\n    elif max_pixels == row['pixels_moderate']:\n        return 'Moderate'\n    else:\n        return 'Low'\n\ncensus_bg['dominant_risk'] = census_bg.apply(get_dominant_risk, axis=1)\n\ncensus_bg['weighted_risk_score'] = (\n    (census_bg['pixels_low'] * 1 + \n     census_bg['pixels_moderate'] * 2 + \n     census_bg['pixels_high'] * 3) / census_bg['pixels_total']\n).fillna(0)\n\nprint(\"\\n‚úì Exposure metrics calculated\")\nprint(f\"\\nDominant risk distribution:\")\nprint(census_bg['dominant_risk'].value_counts())\n\nCalculating population exposure metrics...\n\n‚úì Exposure metrics calculated\n\nDominant risk distribution:\ndominant_risk\nLow         572\nModerate     92\nHigh         92\nNo Data      17\nName: count, dtype: int64\n\n\n\n\nprint(\"\\n\" + \"=\" * 70)\nprint(\"POPULATION EXPOSURE SUMMARY\")\nprint(\"=\" * 70)\n\ntotal_pop = census_bg['total_population'].sum()\n\nprint(f\"\\n Total Population Analyzed: {total_pop:,.0f}\")\nprint(f\"   Block groups: {len(census_bg)}\")\n\nprint(f\"\\n Population by Risk Level:\")\nfor risk_level, pop_col, color in [\n    ('High', 'pop_high_risk'),\n    ('Moderate', 'pop_moderate_risk'),\n    ('Low', 'pop_low_risk')\n]:\n    pop = census_bg[pop_col].sum()\n    pct = pop / total_pop * 100 if total_pop &gt; 0 else 0\n    print(f\"   {color} {risk_level:12}: {pop:&gt;10,.0f} ({pct:&gt;5.1f}%)\")\n\nprint(f\"\\n Block Groups by Dominant Risk:\")\nfor category in ['High', 'Moderate', 'Low', 'No Data']:\n    count = (census_bg['dominant_risk'] == category).sum()\n    print(f\"   {category:12}: {count:&gt;4} block groups\")\n\n\n======================================================================\nPOPULATION EXPOSURE SUMMARY\n======================================================================\n\nüìä Total Population Analyzed: 979,682\n   Block groups: 773\n\nüë• Population by Risk Level:\n   üî¥ High        :    106,846 ( 10.9%)\n   üü† Moderate    :    160,225 ( 16.4%)\n   üü¢ Low         :    686,450 ( 70.1%)\n\nüìç Block Groups by Dominant Risk:\n   High        :   92 block groups\n   Moderate    :   92 block groups\n   Low         :  572 block groups\n   No Data     :   17 block groups\n\n\n\n\nprint(\"\\n\" + \"=\" * 70)\nprint(\"TOP HIGH-RISK AREAS\")\nprint(\"=\" * 70)\n\ntop_high_risk = census_bg.nlargest(10, 'pop_high_risk')[\n    ['GEOID', 'total_population', 'pop_high_risk', 'pct_high', 'weighted_risk_score']\n].copy()\n\nprint(\"\\nTop 10 Block Groups by High-Risk Population:\")\nprint(\"-\" * 70)\n\nfor i, (idx, row) in enumerate(top_high_risk.iterrows(), 1):\n    print(f\"{i:&gt;2}. GEOID {row['GEOID']}\")\n    print(f\"    Total pop: {row['total_population']:,.0f} | High-risk pop: {row['pop_high_risk']:,.0f} ({row['pct_high']:.1f}%)\")\n    print(f\"    Risk score: {row['weighted_risk_score']:.2f}\")\n    print()\n\n\n======================================================================\nTOP HIGH-RISK AREAS\n======================================================================\n\nTop 10 Block Groups by High-Risk Population:\n----------------------------------------------------------------------\n 1. GEOID 150030102021\n    Total pop: 2,834 | High-risk pop: 2,423 (85.5%)\n    Risk score: 2.77\n\n 2. GEOID 150039817001\n    Total pop: 3,490 | High-risk pop: 2,039 (58.4%)\n    Risk score: 2.38\n\n 3. GEOID 150039818031\n    Total pop: 3,054 | High-risk pop: 1,954 (64.0%)\n    Risk score: 2.56\n\n 4. GEOID 150030113003\n    Total pop: 3,432 | High-risk pop: 1,856 (54.1%)\n    Risk score: 2.39\n\n 5. GEOID 150030101032\n    Total pop: 2,226 | High-risk pop: 1,582 (71.1%)\n    Risk score: 2.58\n\n 6. GEOID 150039400061\n    Total pop: 2,447 | High-risk pop: 1,458 (59.6%)\n    Risk score: 2.35\n\n 7. GEOID 150030022031\n    Total pop: 2,009 | High-risk pop: 1,457 (72.5%)\n    Risk score: 2.61\n\n 8. GEOID 150030087063\n    Total pop: 1,879 | High-risk pop: 1,416 (75.3%)\n    Risk score: 2.60\n\n 9. GEOID 150030106022\n    Total pop: 1,881 | High-risk pop: 1,347 (71.6%)\n    Risk score: 2.45\n\n10. GEOID 150030097073\n    Total pop: 1,495 | High-risk pop: 1,328 (88.8%)\n    Risk score: 2.86\n\n\n\n\n\nprint(\"Creating visualizations...\")\n\nfig, axes = plt.subplots(2, 2, figsize=(16, 14))\n\n# Panel A: Population by risk level\nax1 = axes[0, 0]\nrisk_pops = [\n    census_bg['pop_high_risk'].sum(),\n    census_bg['pop_moderate_risk'].sum(),\n    census_bg['pop_low_risk'].sum()\n]\ncolors = ['#e74c3c', '#f39c12', '#2ecc71']\nbars = ax1.bar(['High Risk', 'Moderate Risk', 'Low Risk'], risk_pops, color=colors)\nax1.set_ylabel('Population', fontsize=12)\nax1.set_title('(A) Population by Flood Risk Level', fontsize=14, fontweight='bold')\nax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',')))\n\nfor bar, pop in zip(bars, risk_pops):\n    ax1.annotate(f'{pop:,.0f}', \n                xy=(bar.get_x() + bar.get_width() / 2, bar.get_height()),\n                ha='center', va='bottom', fontsize=11, fontweight='bold')\n\n# Panel B: Dominant risk map\nax2 = axes[0, 1]\nrisk_colors_map = {'Low': '#2ecc71', 'Moderate': '#f39c12', 'High': '#e74c3c', 'No Data': '#cccccc'}\ncensus_bg['risk_color'] = census_bg['dominant_risk'].map(risk_colors_map)\ncensus_bg.plot(ax=ax2, color=census_bg['risk_color'], edgecolor='white', linewidth=0.3)\nax2.set_title('(B) Dominant Risk by Block Group', fontsize=14, fontweight='bold')\nax2.axis('off')\n\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor=c, label=l) for l, c in risk_colors_map.items() if l != 'No Data']\nax2.legend(handles=legend_elements, loc='upper right')\n\n# Panel C: Risk score distribution\nax3 = axes[1, 0]\ncensus_bg['weighted_risk_score'].hist(ax=ax3, bins=30, color='steelblue', edgecolor='white')\nax3.axvline(census_bg['weighted_risk_score'].mean(), color='red', linestyle='--', \n            label=f'Mean: {census_bg[\"weighted_risk_score\"].mean():.2f}')\nax3.set_xlabel('Weighted Risk Score', fontsize=12)\nax3.set_ylabel('Number of Block Groups', fontsize=12)\nax3.set_title('(C) Distribution of Risk Scores', fontsize=14, fontweight='bold')\nax3.legend()\n\n# Panel D: High-risk population map\nax4 = axes[1, 1]\ncensus_bg.plot(ax=ax4, column='pop_high_risk', cmap='Reds', \n               edgecolor='white', linewidth=0.3, legend=True,\n               legend_kwds={'label': 'High-Risk Population', 'shrink': 0.6})\nax4.set_title('(D) High-Risk Population by Block Group', fontsize=14, fontweight='bold')\nax4.axis('off')\n\nplt.suptitle('Population Flood Risk Exposure Analysis - Oahu', \n             fontsize=16, fontweight='bold', y=1.02)\nplt.tight_layout()\nplt.savefig('outputs/figures/population_exposure.png', dpi=300, bbox_inches='tight')\nplt.show()\n\nprint(\"‚úì Saved: outputs/figures/population_exposure.png\")\n\nCreating visualizations...\n\n\n\n\n\n\n\n\n\n‚úì Saved: outputs/figures/population_exposure.png\n\n\n\n\nprint(\"\\nSaving results...\")\n\n# Ensure output directory exists\nPath('outputs/data').mkdir(parents=True, exist_ok=True)\n\n# Save updated shapefile\noutput_cols = [\n    'GEOID', 'geometry', 'total_population',\n    'pixels_low', 'pixels_moderate', 'pixels_high', 'pixels_total',\n    'pct_low', 'pct_moderate', 'pct_high',\n    'pop_low_risk', 'pop_moderate_risk', 'pop_high_risk',\n    'dominant_risk', 'weighted_risk_score'\n]\noutput_cols = [c for c in output_cols if c in census_bg.columns]\ncensus_bg_output = census_bg[output_cols].copy()\n\ncensus_bg_output.to_file('data/processed/census_bg_exposure.shp')\nprint(\"‚úì Saved: data/processed/census_bg_exposure.shp\")\n\n# Save CSV\ncsv_output = census_bg_output.drop(columns='geometry')\ncsv_output.to_csv('outputs/data/population_exposure.csv', index=False)\nprint(\"‚úì Saved: outputs/data/population_exposure.csv\")\n\n# Save summary\ntotal_pop = census_bg['total_population'].sum()\nsummary = {\n    'total_population': total_pop,\n    'pop_high_risk': census_bg['pop_high_risk'].sum(),\n    'pop_moderate_risk': census_bg['pop_moderate_risk'].sum(),\n    'pop_low_risk': census_bg['pop_low_risk'].sum(),\n    'pct_high_risk': census_bg['pop_high_risk'].sum() / total_pop * 100,\n    'pct_moderate_risk': census_bg['pop_moderate_risk'].sum() / total_pop * 100,\n    'pct_low_risk': census_bg['pop_low_risk'].sum() / total_pop * 100,\n    'block_groups_total': len(census_bg),\n    'mean_risk_score': census_bg['weighted_risk_score'].mean()\n}\n\npd.DataFrame([summary]).to_csv('outputs/data/exposure_summary.csv', index=False)\nprint(\"‚úì Saved: outputs/data/exposure_summary.csv\")\n\n\nSaving results...\n‚úì Saved: data/processed/census_bg_exposure.shp\n‚úì Saved: outputs/data/population_exposure.csv\n‚úì Saved: outputs/data/exposure_summary.csv\n\n\n\n\ntotal_pop = census_bg['total_population'].sum()\n\nprint(\"\\n\" + \"=\" * 70)\nprint(\"POPULATION EXPOSURE ANALYSIS COMPLETE\")\nprint(\"=\" * 70)\n\nprint(f\"\"\"\n KEY FINDINGS:\n\n   Total Population Analyzed: {total_pop:,.0f}\n   \n    HIGH RISK:      {census_bg['pop_high_risk'].sum():&gt;10,.0f} people ({census_bg['pop_high_risk'].sum()/total_pop*100:.1f}%)\n    MODERATE RISK:  {census_bg['pop_moderate_risk'].sum():&gt;10,.0f} people ({census_bg['pop_moderate_risk'].sum()/total_pop*100:.1f}%)\n   LOW RISK:       {census_bg['pop_low_risk'].sum():&gt;10,.0f} people ({census_bg['pop_low_risk'].sum()/total_pop*100:.1f}%)\n\n OUTPUT FILES:\n   - data/processed/census_bg_exposure.shp\n   - outputs/data/population_exposure.csv\n   - outputs/data/exposure_summary.csv\n   - outputs/figures/population_exposure.png\n\n‚Üí Proceed to notebook 04 for interactive visualization\n\"\"\")\nprint(\"=\" * 70)\n\n\n======================================================================\nPOPULATION EXPOSURE ANALYSIS COMPLETE\n======================================================================\n\nüìä KEY FINDINGS:\n\n   Total Population Analyzed: 979,682\n\n   üî¥ HIGH RISK:         106,846 people (10.9%)\n   üü† MODERATE RISK:     160,225 people (16.4%)\n   üü¢ LOW RISK:          686,450 people (70.1%)\n\nüìÅ OUTPUT FILES:\n   - data/processed/census_bg_exposure.shp\n   - outputs/data/population_exposure.csv\n   - outputs/data/exposure_summary.csv\n   - outputs/figures/population_exposure.png\n\n‚Üí Proceed to notebook 04 for interactive visualization\n\n======================================================================\n\n\n\n# Create detailed risk profile by block group\nrisk_profile = census_bg[[\n    'GEOID', 'total_population', 'pct_low', 'pct_moderate', 'pct_high',\n    'pop_exposed_low', 'pop_exposed_moderate', 'pop_exposed_high',\n    'weighted_risk_score', 'dominant_risk'\n]].copy()\n\nnumeric_cols = ['pct_low', 'pct_moderate', 'pct_high', 'weighted_risk_score']\nrisk_profile[numeric_cols] = risk_profile[numeric_cols].round(2)\n\npop_cols = ['pop_exposed_low', 'pop_exposed_moderate', 'pop_exposed_high']\nrisk_profile[pop_cols] = risk_profile[pop_cols].round(0).astype(int)\n\nprint(\"\\nüìã Top 20 Highest Risk Block Groups:\")\nprint(\"=\"*100)\ntop_20 = risk_profile.nlargest(20, 'weighted_risk_score')\nprint(top_20.to_string(index=False))\n\nrisk_profile.to_csv('outputs/data/population_risk_profile.csv', index=False)\nprint(f\"\\n‚úì Full risk profile saved to: outputs/data/population_risk_profile.csv\")\n\n\nüìã Top 20 Highest Risk Block Groups:\n====================================================================================================\n       GEOID  total_population  pct_low  pct_moderate  pct_high  pop_exposed_low  pop_exposed_moderate  pop_exposed_high  weighted_risk_score dominant_risk\n150030105092               721     0.00         49.40     50.60                0                   356               365                 2.51          High\n150030042012               754     0.00         56.14     43.86                0                   423               331                 2.44      Moderate\n150030078042               889     0.06         57.15     42.79                1                   508               380                 2.43      Moderate\n150030001221              1207     0.00         65.38     34.62                0                   789               418                 2.35      Moderate\n150030062032              1970     0.00         66.67     33.33                0                  1313               657                 2.33      Moderate\n150030057001              1930     0.00         67.33     32.67                0                  1299               631                 2.33      Moderate\n150030037032               486     0.00         70.00     30.00                0                   340               146                 2.30      Moderate\n150030037013               684     0.00         74.12     25.88                0                   507               177                 2.26      Moderate\n150030013002              1267     0.00         74.07     25.93                0                   939               328                 2.26      Moderate\n150030001171              1381     8.19         58.98     32.84              113                   814               453                 2.25      Moderate\n150030095102               394     0.00         80.00     20.00                0                   315                79                 2.20      Moderate\n150030095111              1438     0.00         79.73     20.27                0                  1147               291                 2.20      Moderate\n150030034044              1558     3.53         73.69     22.78               55                  1148               355                 2.19      Moderate\n150030087042              1830     0.00         81.48     18.52                0                  1491               339                 2.19      Moderate\n150030056021              1307     0.00         81.25     18.75                0                  1062               245                 2.19      Moderate\n150030111041              1403     0.00         82.05     17.95                0                  1151               252                 2.18      Moderate\n150030011011               744     0.00         83.33     16.67                0                   620               124                 2.17      Moderate\n150030084082              3797     0.00         83.33     16.67                0                  3164               633                 2.17      Moderate\n150030049001              1726     0.00         82.76     17.24                0                  1428               298                 2.17      Moderate\n150030001161              2140     0.00         84.33     15.67                0                  1805               335                 2.16      Moderate\n\n‚úì Full risk profile saved to: outputs/data/population_risk_profile.csv\n\n\n\n# Analyze spatial clustering of high-risk areas\nprint(\"=\"*60)\nprint(\"SPATIAL AUTOCORRELATION ANALYSIS\")\nprint(\"=\"*60)\n\ntry:\n    from libpysal.weights import Queen\n    from esda.moran import Moran\n    \n    print(\"‚úì Spatial analysis libraries found\")\n    \nexcept ImportError:\n    print(\" Installing required spatial analysis packages...\")\n    import subprocess\n    import sys\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"esda\", \"libpysal\"])\n    \n    from libpysal.weights import Queen\n    from esda.moran import Moran\n    print(\"‚úì Packages installed successfully\")\n\nprint(\"\\nCalculating Moran's I statistic...\")\n\ntry:\n    # Create spatial weights matrix\n    w = Queen.from_dataframe(census_bg)\n    w.transform = 'r'  # Row-standardized\n    \n    # Calculate Moran's I for weighted risk score\n    moran = Moran(census_bg['weighted_risk_score'], w)\n    \n    print(f\"\\nMoran's I statistic: {moran.I:.4f}\")\n    print(f\"Expected I: {moran.EI:.4f}\")\n    print(f\"P-value: {moran.p_sim:.4f}\")\n    \n    if moran.p_sim &lt; 0.05:\n        if moran.I &gt; 0:\n            print(\"\\n‚úì Significant POSITIVE spatial autocorrelation detected\")\n            print(\"  ‚Üí High-risk areas tend to cluster together\")\n        else:\n            print(\"\\n‚úì Significant NEGATIVE spatial autocorrelation detected\")\n            print(\"  ‚Üí High and low-risk areas alternate spatially\")\n    else:\n        print(\"\\n‚óã No significant spatial autocorrelation detected\")\n        print(\"  ‚Üí Risk distribution appears random\")\n        \nexcept Exception as e:\n    print(f\"\\n Could not compute spatial autocorrelation: {e}\")\n    print(\"This is optional and doesn't affect the main analysis.\")\n    print(\"Continuing with remaining analysis...\")\n\nprint(\"=\"*60)\n\n============================================================\nSPATIAL AUTOCORRELATION ANALYSIS\n============================================================\n‚úì Spatial analysis libraries found\n\nCalculating Moran's I statistic...\n\nMoran's I statistic: 0.0694\nExpected I: -0.0014\nP-value: 0.0040\n\n‚úì Significant POSITIVE spatial autocorrelation detected\n  ‚Üí High-risk areas tend to cluster together\n============================================================\n\n\n\n# Save enhanced census data with all risk metrics\noutput_path = 'data/processed/census_bg_with_risk.shp'\ncensus_bg.to_file(output_path)\nprint(f\"‚úì Enhanced census data saved to: {output_path}\")\n\ngeojson_path = 'data/processed/census_bg_with_risk.geojson'\ncensus_bg.to_file(geojson_path, driver='GeoJSON')\nprint(f\"‚úì GeoJSON version saved to: {geojson_path}\")\n\nsummary_data = {\n    'Metric': [\n        'Total Population',\n        'Population in Low Risk Areas',\n        'Population in Moderate Risk Areas',\n        'Population in High Risk Areas',\n        '% Population in High Risk',\n        'Block Groups Analyzed',\n        'Mean Risk Score',\n        'Median Risk Score'\n    ],\n    'Value': [\n        f\"{census_bg['total_population'].sum():,.0f}\",\n        f\"{census_bg['pop_exposed_low'].sum():,.0f}\",\n        f\"{census_bg['pop_exposed_moderate'].sum():,.0f}\",\n        f\"{census_bg['pop_exposed_high'].sum():,.0f}\",\n        f\"{(census_bg['pop_exposed_high'].sum() / census_bg['total_population'].sum() * 100):.1f}%\",\n        f\"{len(census_bg)}\",\n        f\"{census_bg['weighted_risk_score'].mean():.2f}\",\n        f\"{census_bg['weighted_risk_score'].median():.2f}\"\n    ]\n}\n\nsummary_df = pd.DataFrame(summary_data)\nsummary_df.to_csv('outputs/data/exposure_summary.csv', index=False)\nprint(f\"‚úì Summary statistics saved to: outputs/data/exposure_summary.csv\")\n\nprint(\"\\n‚úì Population exposure analysis complete!\")\n\n‚úì Enhanced census data saved to: data/processed/census_bg_with_risk.shp\n‚úì GeoJSON version saved to: data/processed/census_bg_with_risk.geojson\n‚úì Summary statistics saved to: outputs/data/exposure_summary.csv\n\n‚úì Population exposure analysis complete!"
  }
]